<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Larry Price]]></title>
  <link href="http://larryprice.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://larryprice.github.com/"/>
  <updated>2013-01-05T16:53:30-05:00</updated>
  <id>http://larryprice.github.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Schemaless databases with Ruby and MongoDB]]></title>
    <link href="http://larryprice.github.com/blog/2013/01/05/schemaless-databases-with-ruby-and-mongodb/"/>
    <updated>2013-01-05T16:54:00-05:00</updated>
    <id>http://larryprice.github.com/blog/2013/01/05/schemaless-databases-with-ruby-and-mongodb</id>
    <content type="html"><![CDATA[<p>This is Part 1 in a multi-part series to detail the creation of a "simple" project combining <a href="http://www.ruby-lang.org/">Ruby</a>, <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://rspec.info/">RSpec</a>, <a href="http://www.sinatrarb.com/">Sinatra</a>, and <a href="https://github.com/jnicklas/capybara">Capybara</a> in preperation for a larger-scale side project set to begin January 2013. For more in this series, see the <a href="/blog/categories/pokephile">Pokephile category</a>. Part 1 details getting started with MongoDB and creating a collection using data scraped off the web using <a href="http://nokogiri.org/">Nokogiri</a>. The code for this side-project is located <a href="https://github.com/larryprice/Pokephile">on Github</a></p>

<h3>A little background</h3>

<p>NoSQL is a database service used when working with a large amount of data that doesn't fit a relational model (read: <a href="http://en.wikipedia.org/wiki/Nosql">wikipedia</a>). It allows for mass storage without the overhead of SQL relations. There are many types of schemaless database services (<a href="http://en.wikipedia.org/wiki/Nosql#Taxonomy">here's a list</a>), but in particular I've been looking into what's called "Document Store."</p>

<p>Documents can be any number of key-value fields with a unique id. Document Store services usually encode data in a simple format such as XML, YAML, JSON, or BSON for storage purposes. MongoDB is a document store service which uses BSON to store documents. In Mongo, we connect to a specific database and then we can look through "collections," which are more-or-less equivalent to "tables" in relational databases.</p>

<h3>What about MongoDB and the Ruby driver?</h3>

<p>The first step is to get MongoDB working on your machine. Install MongoDB for your system -- on Ubuntu 12.10 I do this:</p>

<p><code>
sudo apt-get install mongodb mongodb-dev mongodb-clients mongodb-server
</code></p>

<p>Then we start up the daemon:</p>

<p><code>
sudo service mongodb start
</code></p>

<h3>What's the concept?</h3>

<p>The concept here is that we are going to have a database populated with <a href="http://www.pokemon.com/">Pokemon</a>. The user types a Pokemon's name into a search field and submits the form, which brings up an image of the Pokemon and some useful information.</p>

<h3>Getting started</h3>

<p>Since I would like to focus on MongoDB, we can start by populating our database with Pokemon. If you're not familiar with Pokemon, there are lots of them (~650 at the date of this blog post). For my purposes, I may want to only add the first ~150 Pokemon, or I may want to add every Pokemon imaginable. I want it to be easy to add more if any new ones are added. So I'm going to start this project by creating a Populater, and we're going to use TDD to help us create it.</p>

<p>If you don't have RSpec installed, it's as easy as opening up a shell and:</p>

<p><code>
$ sudo gem install rspec mongo
</code></p>

<p>I'm going to put the Populater in a tools directory, and I'm going to put my spec files in a test/spec directory. The directory structure I want to use is as follows:</p>

<p><code>
project
--tools
----populate
----test
------spec
</code></p>

<p>In the 'tools/test/spec' directory, I create 'populater_spec.rb.' We'll write our first test:</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
describe Populater do</p>

<pre><code>describe "#new" do
    it "does not throw when creating instance" do
        expect {Populater.new}.to_not raise_error
    end
end
</code></pre>

<p>end
```</p>

<p>The syntax for RSpec is mostly pseudo-English, so it's fairly straightforward to follow. The first 'describe' block says that we are describing the Populater class. The second 'describe' block says that we are describing the 'new' method of the 'Populater' class. The inner-most block is our test. We want to make sure that no exception is thrown when we create a new Populater. To run this test, open a terminal and type:</p>

<p><code>bash Running Rspec
$ pwd
~/project/tools/test
$ rspec populater_spec.rb
</code></p>

<p>We get a big fat compile error, obviously due to the fact that there's no such thing as a 'Populater' class. So create the file 'populater.rb' in 'project/tools/populate' and create the class:</p>

<p><code>ruby project/tools/populate/populater.rb
class Populater
end
</code></p>

<p>And include the 'Populater' class in our spec file:</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
require_relative '../../populate/populater'</p>

<p>describe Populater do</p>

<pre><code>describe "#new" do
    it "does not throw when creating instance" do
        expect {Populater.new}.to_not raise_error
    end
end
</code></pre>

<p>end
```</p>

<p>Now run rspec. Hooray, we're passing all our tests! Let's add another test and some let's have RSpec do a little work before each test.</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
require_relative '../../populate/populater'</p>

<p>describe Populater do</p>

<pre><code>before:each do
    @populater = Populater.new
end

describe "#new" do
    it "does not throw when creating instance" do
        expect {Populater.new}.to_not raise_error
    end

    it "takes no params and returns a Populater instance" do
        @populater.should be_an_instance_of Populater
    end
end
</code></pre>

<p>end
```</p>

<p>The 'before:each' syntax tells RSpec to perform this action before running each test. This way, we don't have to type out 'Populater.new' in each test. When we run RSpec, this test passes. Now let's actually do something meaningful in our new call. We want the Populater to empty all Pokemon from our database as it begins. In order to do this, we need to also tell the Populater what database to use, so we'll refactor slightly to pass in the name of our database to the Populater.</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
require_relative '../../populate/populater'
require 'mongo'</p>

<p>describe Populater do</p>

<pre><code>before:all do
    @col = Mongo::Connection.new.db('test')["pokemons"]
end
before:each do
    @populater = Populater.new('test')
end

describe "#new" do
    it "does not throw when creating instance" do
        expect {Populater.new('test')}.to_not raise_error
    end

    it "takes one param and returns a Populater instance" do
        @populater.should be_an_instance_of Populater
    end

    it "empties pokemon collection" do
        @col.insert({:test =&gt; "hi there"})
        @col.find.count.should_not eql 0
        Populater.new('test')
        @col.find.count.should eql 0
    end
end
</code></pre>

<p>end
```</p>

<p>Similar to the 'before:each' syntax, the 'before:all' syntax runs the statement once. Here we want to get a handle to the 'pokemons' collection from our 'test' database. In our test, we run a 'find' with no arguments on the 'pokemons' collection to query everything in that collection. We also have an 'insert' statement where we insert an arbitrary document into our collection. You'll note later that this garbage document looks nothing like the Pokemon documents we insert, which is just another reason to love document-store databases. We run RSpec and we fail the test. Let's open up 'populater.rb' and fix this.</p>

<p>``` ruby project/tools/populate/populater.rb
require 'mongo'</p>

<p>class Populater</p>

<pre><code>def initialize(db_name)
    @col = Mongo::Connection.new.db(db_name)["pokemons"]
    @col.remove
end
</code></pre>

<p>end
```</p>

<p>Test fixed. We connect to the same database and access the same collection and remove all the old data on intialize. So now we actually want to add Pokemon to the collection. We'll pick up a new 'describe' block for an 'add_pokemon' method. We'll then test that calling it with 0 adds no Pokemon to the collection.</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
...
describe "#add_pokemon" do</p>

<pre><code>it "adds 0 pokemon given 0" do
    @populater.add_pokemon 0
    @col.find.count.should eql 0
end
</code></pre>

<p>end
...
```</p>

<p>When we run our tests, we get a NoMethodError and fail. We create a trivial fix in populater.rb</p>

<p>``` ruby project/tools/populate/populater.rb
class Populater</p>

<pre><code>...

def add_pokemon(num)
end
</code></pre>

<p>end
```</p>

<p>And we pass the test, having added 0 Pokemon to our database. Let's do it with 1 now.</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
...
describe "#add_pokemon" do</p>

<pre><code>...
it "adds 1 pokemon given 1" do
    @populater.add_pokemon 1
    @col.find.count.should eql 1
end
</code></pre>

<p>end
...
```</p>

<p>We fail. Another trivial fix:</p>

<p>``` ruby project/tools/populate/populater.rb
class Populater</p>

<pre><code>...

def add_pokemon(num)
    (0...num).each do |x|
        @col.insert({number: x})
    end
end
</code></pre>

<p>end
```</p>

<p>We pass again. We'll also pass when checking for multiple Pokemon:</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
...
describe "#add_pokemon" do</p>

<pre><code>...
it "adds 2 pokemon given 2" do
    @populater.add_pokemon 2
    @col.find.count.should eql 2
end
</code></pre>

<p>end
...
```</p>

<p>But we're missing substance. There's only garbage being shoved in our database. Our TDD methodology breaks down slightly here because we want our database to have dynamic information scraped from a website, and I don't want to hard code any data nor do I want to scrape the same website in my tests and my implementation. So we're going to do a little bit of behind-the-scenes stuff and test that the fields we want are simply not nil. I want each Pokemon to have a number, name, an array of types, and a link to an image:</p>

<p>``` ruby project/tools/test/spec/populater_spec.rb
...
describe "#add_pokemon" do</p>

<pre><code>...
it "adds pokemon with a number" do
    @populater.add_pokemon 1
    @col.find.count.should eql 1
    @col.find.first['number'].should_not be_nil
end
it "adds pokemon with a name" do
    @populater.add_pokemon 1
    @col.find.count.should eql 1
    @col.find.first['name'].should_not be_nil
end
it "adds pokemon with array of types" do
    @populater.add_pokemon 1
    @col.find.count.should eql 1
    types = @col.find.first['types']
    types.should_not be_nil
    types.should be_an_instance_of Array
    types.should have_at_least(1).items
    types.should have_at_most(2).items
end
it "adds pokemon with image link" do
    @populater.add_pokemon 1
    @col.find.count.should eql 1
    image = @col.find.first['image']
    image.should_not be_nil
    image.should_not be_empty
end
</code></pre>

<p>end
...
```</p>

<p>There are many websites where you can get this kind of data for each Pokemon, but I chose <a href="http://pokemon.wikia.com/wiki/List_of_Pok%C3%A9mon">the Pokemon Wiki</a> for its consistency. In the initializer of the Populater, I open up the URL using Nokogiri so I can access the sweet, creamy data contained within. In my add_pokemon method, I extract this data I want based on the way the table is set up on the website. To continue, we need to install the Nokogiri gem:</p>

<p><code>
sudo gem install nokogiri
</code></p>

<p>And now we add the logic to add_pokemon:</p>

<p>``` ruby project/tools/populate/populater.rb
require 'mongo'
require 'nokogiri'
require 'open-uri'</p>

<p>class Populater</p>

<pre><code>def initialize(db_name)
    @col = Mongo::Connection.new.db(db_name)["pokemons"]
    @col.remove
    @data = Nokogiri::HTML(open("http://pokemon.wikia.com/wiki/List_of_Pok%C3%A9mon"))
end

def add_pokemon(num_to_add)
    @data.xpath("//table[@class='wikitable sortable']/tr").each do |row|
        break if num_to_add &lt;= 0
        dex_num = row.at_xpath('td/text()').to_s.strip
        next if dex_num.nil? || dex_num.empty?
        dex_name = row.at_xpath('td[2]/a/text()').to_s.strip

        unless dex_num == "000"
            type_1 = row.at_xpath('td[4]/a/span/text()').to_s.strip
            type_2 = row.at_xpath('td[5]/a/span/text()').to_s.strip || row.at_xpath('td[5]/text()').to_s.strip
            image_link = "http://img.pokemondb.net/artwork/#{dex_name.downcase}.jpg"
        else
            type_1 = row.at_xpath('td[4]/text()').to_s.strip
            type_2 = row.at_xpath('td[5]/text()').to_s.strip
            image_link = "images/missingo.png"
        end

        types = Array.new
        types &lt;&lt; type_1 unless type_1.nil? || type_1.empty?
        types &lt;&lt; type_2 unless type_2.nil? || type_2.empty?

        @col.insert({:number =&gt; dex_num, :name =&gt; dex_name, :types =&gt; types, :image =&gt; image_link})

        num_to_add -= 1
    end
end
</code></pre>

<p>end
```</p>

<p>I'll admit The add_pokemon method is now quite a bit more daunting to interpret. Here's the breakdown of what's going on: Nokogiri finds us the table tag with class of 'wikitable sortable' and we iterate over that. There are two breaking conditions of our loop: we hit the max number of Pokemon as given, or we can't find anymore Pokemon in the table. So we check that we haven't hit our max. Then we find the Pokemon's number in the table after we manually parse the HTML. In the case of this table, the first row is all garbage, so we continue to the next row if we are on the first row.  We then grab the name from the table, which is luckily always in the same place. The branch is for the special case of Pokemon #000 (Missingo), which is set up slightly differently in the table for some reason. We create an empty array and shove our types in it, but we have to be careful because not all Pokemon have two types. We then create a document in the braces and insert it into the collection. The final step is to decrement the loop counter.</p>

<p>Tests pass. We now have a working Populater! Now we can either write a script or open up the irb and populate as necessary and we know that the Populater is functional:</p>

<p>``` ruby Populating Databases
$ irb</p>

<blockquote><blockquote><p>Dir.pwd
=> "project/tools/populate"
require 'mongo'
=> true
col = Mongo::Connection.new.db('dev')["pokemons"]
=> ...
col.find.count
=> 0
require './populater'
=> true
Populater.new('dev').add_pokemon 152
=> nil
col.find.count
152</p>

<p>```</p></blockquote></blockquote>

<p>If you want to further familiarize yourself with the MongoDB Ruby driver, you should check out the MongoDB Koans. Unfortunately, the original <a href="https://github.com/tredfern/MongoDB_Koans">MongoDB Koans</a> have not been updated in a while, and so my more recent installations of Ruby and the MongoDB driver didn't work. I found a set of <a href="https://github.com/edgecase/ruby_koans">updated koans</a> which worked with my install of Ruby 1.9.3. However, the updated version also had a couple of annoying issues with deprecations, so I created <a href="https://github.com/larryprice/MongoDB_Koans">my own fork</a> on GitHub with the fixes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Hacky Solution to the Unicode data in a Unicode-only collation problem]]></title>
    <link href="http://larryprice.github.com/blog/2012/10/19/a-hacky-solution-to-the-unicode-data-in-a-unicode-only-collation-problem/"/>
    <updated>2012-10-19T17:23:00-04:00</updated>
    <id>http://larryprice.github.com/blog/2012/10/19/a-hacky-solution-to-the-unicode-data-in-a-unicode-only-collation-problem</id>
    <content type="html"><![CDATA[<h2>The Issue Rises <a id="problem"></a></h2>

<p>Earlier this week a defect was found in my application. A defect that I could have sworn I fixed several weeks ago and written about in a <a href="http://nullablevoid.blogspot.com/2012/10/unicode-data-in-unicode-only-collation.html">previous blog post</a>. Let me start from the beginning:</p>

<h4>The Setup</h4>

<p>The application is a web app using Rails 3.2, MSSQL Server for the database, and Tiny-TDS for database communications from the CloudFoundry server. There are three different types of builds and three databases I access: development (for development, obviously), staging (for testing), and production (for the users to complain about, mostly).</p>

<h4>The Original Issue</h4>

<p>I inherited this code and ran it on my dev build with no issues. Upon doing some testing with the staging build, the page crashed. The logs revealed the following (horrible) error:</p>

<p><code>ruby Vague error
Unicode data in a Unicode-only collation or ntext data cannot be sent to clients using DB-Library (such as ISQL) or ODBC version 3.7 or earlier.
</code></p>

<p>What does this mean? Well. Beats me. <a href="http://dirk.net/2010/09/18/sql-server-with-freetds-unicode-data-error/">Several</a> <a href="http://stackoverflow.com/questions/5414890/mssql-query-issue-in-php-and-querying-text-data">sources</a> had <a href="http://stackoverflow.com/questions/8705008/tiny-tds-error-on-heroku-connecting-to-sqlserver-db">similar</a> <a href="http://findyourscript.com/index.php/2011/05/20/unicode-data-in-a-unicode-only-collation-or-ntext-data-cannot-be-sent-to-clients-using-db-library/">issues</a> and the ones I liked eventually came to the conclusion that ntext and nvarchar variables in the database were ticking off the host server. <a href="http://msdn.microsoft.com/en-us/library/ms186939.aspx">Apparently</a>, text variables are translated to nvarchar(MAX), where MAX is something like 2GB of data. I hunted through my database and, sure enough, the 'Narrative' column was an nvarchar(MAX).</p>

<h4>The Original Fix</h4>

<p>Based on the mighty power of the internet, I decided that the best thing for me to do was to change the variable in the database from a "text" to a "string" with a limit of 8000 (which translates to varchar(8000)) using this migration:</p>

<p>``` ruby Simple migration
class ChangeNarrativeColumnToVarChar &lt; ActiveRecord::Migration
  def change</p>

<pre><code>change_column :evaluation, :narrative, :string, :limit =&gt; 8000
</code></pre>

<p>  end
```</p>

<p>I ran through my repro steps and... Drumroll... Suspense... It worked! Or so it appeared. I went to the narrative textbox and put some words in it, saved, and confirmed that everything was great. Then I pushed it to production and heard nothing for two weeks.</p>

<h2>Failure Is Always An Option <a id="failure"></a></h2>

<p>Too bad that wasn't the end of the story. This week my users finally started using the app again. They found all kinds of defects, of course, but one in particular that caught me off guard: When viewing the narrative text, which we had "fixed" using that little migration above, the text cut off to about two lines. Two lines? I never really bothered to test more than a couple words or a short, goofy phrase. So I opened up the app on my dev build and it worked great with up to 8000 characters. I switched over to the staging build and was able to reproduce the error immediately.</p>

<p>At first I thought it was just the test_area, but I was wrong. Even static fields which displayed narrative cut off text. After some testing, the text was always cut off to 255 characters. I watched the SQL logs and confirmed that all 8000 characters would come back from the SQL queries. I looked in the database and verified the data was still present. What was going on?</p>

<h4>Dear Rails: Oh, you</h4>

<p>I thought and eventually realized something: the default of a "string" in Rails is 255 characters. Rails was cutting off my text. Curse you, Rails, I trusted you with my heart!</p>

<h4>The Fix</h4>

<p>Alright. The fix. Unfortunately, the fix sucks. In my app, I had to get the whole model that contained a narrative. Doing only that, the narrative would be cut short. So then I had to get the narrative again, and this time cast that sucker to a "text."</p>

<p><code>ruby &lt; 1337 Hax
@eval = Evaluation.find(:id =&gt; id)
@eval.narrative = Evaluation.select("id as id, CAST(narrative as text) as narrative").where(:id =&gt; id).first.narrative
</code></p>

<p>There's a part of me that likes sensible, clean code. This code did not come from that part of me. If you really want, you can do a select and get all the columns of your model, and then case the field in question, but what if your columns change? I didn't want to be responsible for that, especially after I hand this code off to someone else in the coming weeks.</p>
]]></content>
  </entry>
  
</feed>
