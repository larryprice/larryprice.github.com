<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-08-02T20:32:12-04:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jasmine - A Whole New World of Javascript Testing]]></title>
    <link href="http://larry-price.com/blog/2014/06/04/jasmine-a-whole-new-world-of-javascript-testing/"/>
    <updated>2014-06-04T06:19:43-04:00</updated>
    <id>http://larry-price.com/blog/2014/06/04/jasmine-a-whole-new-world-of-javascript-testing</id>
    <content type="html"><![CDATA[<p><a href="https://jasmine.github.io/">Jasmine</a>: a headless Javascript testing library written entirely in Javascript. With similarities to <a href="http://rspec.info">rspec</a>, I&rsquo;ve quickly grown attached to this framework and have been looking for opportunities to discuss it. <a href="https://jasmine.github.io/2.0/introduction.html">Version 2.0</a> was recently released, so I&rsquo;ll be focusing on the standalone 2.0 concepts. To get started, download and uncompress <a href="https://github.com/pivotal/jasmine/tree/master/dist">the standalone distribution</a>.</p>

<p>The uncompressed directory structure will have three subdirectories: <code>spec</code>, <code>src</code>, and <code>lib</code>. <code>lib</code> contains all the Jasmine source code. <code>src</code> contains some sample Javascript class that is tested by test files contained in <code>spec</code>. Outside of the subdirectories is the special file <code>SpecRunner.html</code>. This file is how we will run our tests.</p>

<p>Let&rsquo;s start a new pizza place.</p>

<p>We&rsquo;ll need Pizza. A Pizza will need several things: size, style, toppings, and price. We&rsquo;ll have a few styles available, but also allow our guests to request additional toppings. We&rsquo;ll also set the price based on the size and number of toppings. Create the files <code>src/pizza.js</code> and <code>spec/PizzaSpec.js</code> and add them to <code>SpecRunner.html</code>.</p>

<p>We&rsquo;ll start by being able to get the styles from Pizza.</p>

<p>``` js spec/PizzaSpec.js
describe(&ldquo;Pizza&rdquo;, function() {
  var pizza;</p>

<p>  beforeEach(function() {</p>

<pre><code>pizza = new Pizza();
</code></pre>

<p>  });</p>

<p>  it(&ldquo;should give a choice of styles&rdquo;, function() {</p>

<pre><code>expect(pizza.getStyles()).toContain("meat lovers");
expect(pizza.getStyles()).toContain("veg head");
expect(pizza.getStyles()).toContain("supreme");
</code></pre>

<p>  });
});
```</p>

<p>The syntax is just lovely: We use <code>describe</code> to set visual context, <code>beforeEach</code> to perform a task before each spec, and <code>it</code> to encapsulate a test. The results of running <code>SpecRunner.html</code> in my browser:</p>

<p><code>
Pizza should give a choice of styles
  TypeError: pizza.getStyles is not a function in file:///home/lrp/docs/jasmine/spec/PizzaSpec.js (line 9)
</code></p>

<p>Fixing it:</p>

<p>``` js src/pizza.js
function Pizza() {
  this.getStyles = function() {</p>

<pre><code>return ["meat lovers", "veg head", "supreme"];
</code></pre>

<p>  }
}
```</p>

<p>And the results:</p>

<p>```
Pizza</p>

<pre><code>should give a choice of styles
</code></pre>

<p>```</p>

<p>Let&rsquo;s set the toppings:</p>

<p>``` js spec/PizzaSpec.js
describe(&ldquo;Pizza&rdquo;, function() {
  // &hellip;</p>

<p>  describe(&ldquo;toppings&rdquo;, function() {</p>

<pre><code>it("should have no toppings when no style and no extras given", function() {
  pizza.initialize();
  expect(pizza.getToppings().length).toBe(0);
});

it("should have only extras when no style and extras given", function() {
  var extras = ["pineapple", "edamame", "cheeseburger"]
  pizza.initialize(null, null, extras);

  expect(pizza.getToppings().length).toBe(extras.length);
  for (var i = 0; i &lt; extras.length; i++) {
    expect(pizza.getToppings()).toContain(extras[i]);
  }
});

it("should have special toppings when given style and extras", function() {
  var extras = ["pineapple", "edamame", "cheeseburger"];
  pizza.initialize(null, "veg head", extras);

  expect(pizza.getToppings().length).toBe(7);
});

it("should have special toppings when given style", function() {
  var extras = ["pineapple", "edamame", "cheeseburger"];
  pizza.initialize(null, "veg head");

  expect(pizza.getToppings().length).toBe(4);
});
</code></pre>

<p>  });
});
```</p>

<p>For these tests, I nested a describe block to give better context to what I&rsquo;m testing. Fixing the tests:</p>

<p>``` js src/pizza.js
function Pizza() {
  // &hellip;</p>

<p>  var size, toppings;</p>

<p>  function findToppings(style, extras) {</p>

<pre><code>toppings = extras ? extras : [];

switch (style) {
  case ("meat lovers"):
    toppings.push("ham", "pepperoni", "bacon", "sausage");
    break;
  case ("veg head"):
    toppings.push("onion", "tomato", "pepper", "olive");
    break;
  case ("supreme"):
    toppings.push("pepperoni", "onion", "sausage", "olive");
    break;
}
</code></pre>

<p>  }</p>

<p>  this.getToppings = function() {</p>

<pre><code>return toppings;
</code></pre>

<p>  };</p>

<p>  this.initialize = function(pizzaSize, style, extras) {</p>

<pre><code>size = pizzaSize;
findToppings(style, extras);
</code></pre>

<p>  };
}
```</p>

<p>And finally, I&rsquo;ll deal with the cost. I&rsquo;ll come out of scope of the nested <code>describe</code> and nest another <code>describe</code>.</p>

<p>``` js spec/PizzaSpec.js
describe(&ldquo;Pizza&rdquo;, function() {
  // &hellip;</p>

<p>  describe(&ldquo;cost&rdquo;, function() {</p>

<pre><code>it("is determined by size and number of toppings", function() {
  pizza.initialize(10, "supreme");
  expect(pizza.getToppings().length).toBe(4);
  expect(pizza.getCost()).toBe(7.00);
});

it("is determined by size and number of toppings including extras", function() {
  pizza.initialize(18, "meat lovers", ["gyros", "panchetta"]);
  expect(pizza.getToppings().length).toBe(6);
  expect(pizza.getCost()).toBe(12.00);
});
</code></pre>

<p>  });
});
```</p>

<p>To fix this test, I&rsquo;ll use my handy-dandy pizza-cost formula:</p>

<p>``` js src/pizza.js
function Pizza() {
 // &hellip;</p>

<p>  this.getCost = function() {</p>

<pre><code>return size/2 + toppings.length * .5;
</code></pre>

<p>  }</p>

<p>  // &hellip;
}
```</p>

<p>This is great and all, but a bit simple. What if we wanted to make an ajax call? Fortunately, I can fit that into this example using <a href="http://onlinepizza.se/api/">Online Pizza</a>, the pizza API. Unfortuantely, the API is kind of garbage, but that doesn&rsquo;t make this example any more meaningless. You can <a href="https://github.com/pivotal/jasmine-ajax/raw/master/lib/mock-ajax.js">download jasmine-ajax on Github</a>, and stick it in your <code>spec/</code> directory and add it to <code>SpecRunner.html</code>. At this point I need to include <a href="">jquery</a> as well.</p>

<p>In order to intercept ajax calls, I&rsquo;ll <code>install</code> the ajax mocker in the <code>beforeEach</code> and uninstall it in an <code>afterEach</code>. Then I write my test, which verifies that the ajax call occurred and returns a response.</p>

<p>``` js spec/PizzaSpec.js
beforeEach(function() {
  jasmine.Ajax.install();</p>

<p>  pizza = new Pizza();
});</p>

<p>afterEach(function() {
  jasmine.Ajax.uninstall();
});</p>

<p>describe(&ldquo;sendOrder&rdquo;, function() {
  it(&ldquo;returns false for bad pizza&rdquo;, function() {</p>

<pre><code>pizza.sendOrder();

expect(jasmine.Ajax.requests.mostRecent().url).toBe("http://onlinepizza.se/api/rest?order.send");

jasmine.Ajax.requests.mostRecent().response({
  status: "500",
  contentType: "text/plain",
  responseText: "Invalid pizza"
});

expect(pizza.orderSent()).toBe(false);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns true for good pizza&rdquo;, function() {</p>

<pre><code>pizza.sendOrder();

expect(jasmine.Ajax.requests.mostRecent().url).toBe("http://onlinepizza.se/api/rest?order.send");

jasmine.Ajax.requests.mostRecent().response({
  status: "200",
  contentType: "text/plain",
  responseText: "OK"
});

expect(pizza.orderSent()).toBe(true);
</code></pre>

<p>  });
});
```</p>

<p>To get this to work, I add some logic to the <code>Pizza</code> class to set some state based on what the ajax call returns.</p>

<p>``` js src/pizza.js
var orderSuccess;</p>

<p>this.sendOrder = function() {
  orderSuccess = null;</p>

<p>  $.ajax({</p>

<pre><code>type: "POST",
url: "http://onlinepizza.se/api/rest?order.send",
success: function() {
  orderSuccess = true;
},
error: function() {
  orderSuccess = false;
}
</code></pre>

<p>  });
}</p>

<p>this.orderSent = function() {
  return orderSuccess;
}
```</p>

<p>Ajax calls tested. By installing Jasmine&rsquo;s ajax mock, all of the ajax calls were intercepted and were not sent to the server at Online Pizza. Any ajax calls that may have been fired by the <code>Pizza</code> class but were not addressed in the spec are ignored. The final test results look something like this:</p>

<p>```
Pizza</p>

<pre><code>sendOrder
    returns false for bad pizza
    returns true for good pizza
styles
    should give a choice of styles
toppings
    should have no toppings when no style and no extras given
    should have only extras when no style and extras given
    should have special toppings when given style and extras
    should have special toppings when given style
cost
    is determined by size and number of toppings
    is determined by size and number of toppings including extras
</code></pre>

<p>```</p>

<p>Full sample code <a href="https://github.com/larryprice/jasmine-pizza">available on Github</a>. There&rsquo;s a lot of other interesting things Jasmine can do that I&rsquo;m still learning about. If applicable, I&rsquo;ll try to create a blog post for advanced Jasmine usage in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Better testing in Go with gocheck]]></title>
    <link href="http://larry-price.com/blog/2014/05/13/better-testing-in-go-with-gocheck/"/>
    <updated>2014-05-13T21:14:39-04:00</updated>
    <id>http://larry-price.com/blog/2014/05/13/better-testing-in-go-with-gocheck</id>
    <content type="html"><![CDATA[<p>As a quick reminder, <a href="//golang.org/">golang</a> is a really fun programming language to use. It even includes <a href="//golang.org/doc/code.html#Testing">testing out of the box</a>! Unfortunately, this out-of-the-box testing framework isn&rsquo;t all that great. It lacks the syntactic sugar of mature frameworks like <a href="//rspec.info">rspec</a> or <a href="//code.google.com/p/googletest/">gtest</a>.</p>

<p>Of course, there are alternatives. I found an open-source library (licensed with Simplified BSD) called <a href="//labix.org/gocheck">gocheck</a>.</p>

<p>Gocheck, how do I love thee? Let me count the ways:</p>

<ul>
<li>Test fixtures</li>
<li>Improved assertions</li>
<li>Improved test output</li>
<li>Sugar-coated syntax</li>
<li>Test skipping</li>
<li>Oh my</li>
</ul>


<p>As usual, it&rsquo;s time to guide you through a contrived example. Start by installing the package:</p>

<p><code>bash
$ go get gopkg.in/check.v1
</code></p>

<p>Let&rsquo;s see, what should we make&hellip; how about a tip calculating library? We should start by testing, because we&rsquo;re obsessed with TDD.</p>

<p>Test #1: Returns 0 for free meal</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{}</p>

<p>var _ = Suite(&amp;MySuite{})</p>

<p>func (s <em>MySuite) TestReturns0ForFreeMeal(c </em>C) {
  c.Assert(calculateTip(0.0), Equals, 0.0)
}
```</p>

<p>Not quite as obvious as the internal testing framework. First we hook up gocheck into the &ldquo;go test&rdquo; runner. Then we create a test suite; ours is empty for now and called <code>MySuite</code>. We call <code>Suite</code> to intialize the test runner with our custom suite. We then write our first test to assert that calculating the tip returns a value equal to 0. All tests must be prefixed with the word &ldquo;Test&rdquo;. Now I&rsquo;ll write the implementation:</p>

<p>``` go calculator.go
package cheapskate</p>

<p>func calculateTip(bill float64) float64 {
  return 0.0
}
```</p>

<p>Running the tests&hellip;</p>

<p><code>bash
$ go test
OK: 1 passed
PASS
ok    _/home/lrp/Projects/2014/gocheck-quick  0.003s
</code></p>

<p>Woohoo! All passed. What happens if we write a failing test?</p>

<p><code>go calculator_test.go
...
func (s *MySuite) TestReturns15PercentByDefault(c *C) {
  c.Assert(calculateTip(100.0), Equals, 15.0)
}
</code></p>

<p>Results:</p>

<p>``` bash
lrp@cilantro:~/Projects/2014/gocheck-quick$ go test</p>

<hr />

<p>FAIL: calculator_test.go:19: MySuite.TestReturns15PercentByDefault</p>

<p>calculator_test.go:20:</p>

<pre><code>c.Assert(calculateTip(100.0), Equals, 15.0)
</code></pre>

<p>&hellip; obtained float64 = 0
&hellip; expected float64 = 15</p>

<p>OOPS: 1 passed, 1 FAILED
&mdash;&ndash; FAIL: Test (0.00 seconds)
FAIL
exit status 1
FAIL  _/home/lrp/Projects/2014/gocheck-quick  0.003s
```</p>

<p>A nasty failure that one. I&rsquo;ll fix it and continue:</p>

<p>``` go calculator.go
package cheapskate</p>

<p>func calculateTip(bill float64) float64 {
  return .15 * bill
}
```</p>

<p>I want to create a Setup method for my entire suite. I&rsquo;ll store some silly information there for information&rsquo;s sake. The minBill and maxBill variables will only be set when I first load the suite.</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{
  minBill float64
  maxBill float64
}</p>

<p>func (s <em>MySuite) SetUpSuite(c </em>C) {
  s.minBill = 0
  s.maxBill = 100
}</p>

<p>var _ = Suite(&amp;MySuite{})</p>

<p>func (s <em>MySuite) TestReturns0ForFreeMeal(c </em>C) {
  c.Assert(calculateTip(s.minBill), Equals, 0.0)
}</p>

<p>func (s <em>MySuite) TestReturns15PercentByDefault(c </em>C) {
  c.Assert(calculateTip(s.maxBill), Equals, 15.0)
}
```</p>

<p>What if I wanted to set some information at the start of each test? I&rsquo;ll log the current test number on the suite, updating it every time I run a test:</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;</p>

<p>  &ldquo;fmt&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{
  testNumber int
}</p>

<p>func (s <em>MySuite) SetUpTest(c </em>C) {
  fmt.Println(s.testNumber)
  s.testNumber += 1
}
&hellip;
```</p>

<p>Result:</p>

<p><code>bash
$ go test
0
1
OK: 2 passed
PASS
ok    _/home/lrp/Projects/2014/gocheck-quick  0.004s
</code></p>

<p>You can create tear down methods for suites and tests in the same manner, replacing the appropriate words above.</p>

<p>There&rsquo;s loads of other cool stuff gocheck can do, I&rsquo;ve barely scratched the surface with what little experience I&rsquo;ve had using it. Like any testing framework, I&rsquo;m sure it has its advantages and disadvantages, but it sure beats the pants off the off-the-shelf framework Google includes with golang.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hooks in cucumber-cpp]]></title>
    <link href="http://larry-price.com/blog/2013/11/22/hooks-in-cucumber-cpp/"/>
    <updated>2013-11-22T20:40:00-05:00</updated>
    <id>http://larry-price.com/blog/2013/11/22/hooks-in-cucumber-cpp</id>
    <content type="html"><![CDATA[<p>A few months ago <a href="/blog/2013/04/15/tags-in-c-plus-plus-cucumber-tests/">I blogged about tags</a> in <a href="https://github.com/cucumber/cucumber-cpp">cucumber-c++</a>. The scenario I presented involved using tags to call a <code>BEFORE</code> hook before the first scenario and an <code>AFTER</code> hook after the last scenario. The code looked a little bit like this:</p>

<p>``` cucumber DoStuff.feature
@first
Scenario: Do it my way
  &hellip;</p>

<p>Scenario: Don&rsquo;t do it
  &hellip;</p>

<p>@last
Scenario: Do it your way
  &hellip;
```</p>

<p>``` c++ DoStuff_StepDefinitions.cpp</p>

<p>BEFORE(&ldquo;@first&rdquo;) { cout &lt;&lt; &ldquo;This is the first step!&rdquo; &lt;&lt; endl; }</p>

<p>AFTER(&ldquo;@last&rdquo;) { cout &lt;&lt; &ldquo;This is the last step!&rdquo; &lt;&lt; endl; }</p>

<p>&hellip;</p>

<p>```</p>

<p>The scnenario labeled <code>@first</code> would call the corresponding <code>BEFORE</code> macro and the <code>@last</code> scenario would call the <code>AFTER</code> macro. If I didn&rsquo;t have tags in place, the macros would have both been invoked before/after each scenario. Macros for <code>BEFORE_STEP</code> and <code>AROUND_STEP</code> are also available; <code>BEFORE_STEP</code> allows you to tag individual steps and <code>AROUND_STEP</code> acts as a before/after for individual steps.</p>

<p>This was a workaround. What I really wanted to do was to not use tags, and instead unconditionally perform an action before the first scenario was run and after the last scenario is complete. Since cucumber-cpp is open source, I decided to implement that a few weeks ago (<a href="https://github.com/cucumber/cucumber-cpp/commit/26e11d0248edf32a8bac17df9d2d4ceb135ed502">see changeset</a>). Now the above example becomes:</p>

<p>``` cucumber DoStuff.feature</p>

<p>Scenario: Do it my way
  &hellip;</p>

<p>Scenario: Don&rsquo;t do it
  &hellip;</p>

<p>Scenario: Do it your way
  &hellip;
```</p>

<p>``` c++ DoStuff_StepDefinitions.cpp</p>

<p>BEFORE_ALL() { cout &lt;&lt; &ldquo;This is the first step!&rdquo; &lt;&lt; endl; }</p>

<p>AFTER_ALL() { cout &lt;&lt; &ldquo;This is the last step!&rdquo; &lt;&lt; endl; }</p>

<p>&hellip;</p>

<p>```</p>

<p>This is the same behavior as the first example, except I don&rsquo;t have to force my fellow developers to move tags around when they add/remove scenarios. Also now my fellow developers can stop asking me why I was using tags and why when they added a scenario they couldn&rsquo;t get the tests to pass.</p>

<p>The moral of the story is that you should go implement that feature you want to see in your favorite open source project.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tags in C++ Cucumber tests]]></title>
    <link href="http://larry-price.com/blog/2013/04/15/tags-in-c-plus-plus-cucumber-tests/"/>
    <updated>2013-04-15T22:10:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/04/15/tags-in-c-plus-plus-cucumber-tests</id>
    <content type="html"><![CDATA[<p>The project I&rsquo;m working on is slowly adding <a href="https://github.com/cucumber/cucumber-cpp">Cucumber</a> acceptance tests to our massive code base in order to replace aging <a href="https://code.google.com/p/robotframework/">Robot tests</a>. One would think that getting developers on our team to use Cucumber would be east, since it uses <a href="https://code.google.com/p/googletest/">googletest</a> and <a href="https://code.google.com/p/googlemock/">googlemock</a> which we use for our unit tests. Unfortunately, very few people on the team have been motivated to write integration tests using the new framework, so I have very few people to go to when I have problems writing my own integration tests.</p>

<p>The area of the code I deal with uses <a href="http://www.mono-project.com/Embedding_Mono">embedded mono</a> to communicate with some C# libraries that we share with other applications. This means we have unmanaged memory which talks with managed memory. This has caused us more headaches than I care to remember. One such problem is that we have a static object that we only want to create and destroy once. So I write my first Cucumber test:</p>

<p>``` cucumber DoStuff.feature
Feature: Do that thing that we have to do</p>

<p>Scenario: Do it my way
  Given I have done step 1
  When I do step 2
  Then I should see results
```</p>

<p>``` c++ DoStuff_StepDefinitions.cpp</p>

<h1>include &lt;cucumber-cpp/defs.hpp></h1>

<h1>include &lt;gtest/gtest.h></h1>

<h1>include &lt;mono/jit/jit.h></h1>

<p>const QString DOMAIN_NAME = &ldquo;bridge&rdquo;;</p>

<p>class Context
{
  // The static Mono object
  static MonoDomain *Domain;
}</p>

<p>BEFORE() { Context::Domain = mono_jit_init(DOMAIN_NAME); }</p>

<p>AFTER() { mono_jit_cleanup(Context::Domain); }</p>

<p>GIVEN(&ldquo;^I have done step 1$&rdquo;) { /<em> &hellip; </em>/ }</p>

<p>WHEN(&ldquo;^I do step 2$&rdquo;) { /<em> &hellip; </em>/ }</p>

<p>THEN(&ldquo;^I should see results$&rdquo;) { /<em> &hellip; </em>/ }</p>

<p>```</p>

<p>Before my scenario starts, the <code>BEFORE()</code> function is called and my MonoDomain object is created. When the scenario ends, my <code>AFTER()</code> statement is called and the objects in my MonoDomain are cleaned up. Now, I add a second scenario.</p>

<p>``` cucumber DoStuff.feature
Feature: Do that thing that we have to do</p>

<p>Scenario: Do it my way
  &hellip;</p>

<p>Scenario: Do it your way
  &hellip;
```</p>

<p>Now I run my Cucumber test, and Mono explodes. Why? Because the <code>BEFORE()</code> and <code>AFTER()</code> functions are not <em>before all</em> and <em>after all</em>, but <em>before each</em> and <em>after each</em>.</p>

<p>So what should we do? Move the function calls in the <code>BEFORE()</code> and <code>AFTER()</code> statements into the constructor and destructor of the Context class?</p>

<p>Same problem. Are there <code>BEFORE_ALL()</code> and <code>AFTER_ALL()</code> macros? No.</p>

<p>I began to panic. I asked the person who taught me how to write Cucumber tests in C++. Our idea was to create the MonoDomain during what I knew would be the first step, and delete it after what I knew would be the last step. Oh, the horror! That would mean not being able to reuse those steps, not to mention moving the creation/destruction code around anytime I wanted to add new steps or change the order of my previous steps. We also thought about making specific steps and sticking them at the front of the first scenario and at the end of the last scenario. This still meant that the lay developer would have to recognize these first and last steps from the others. I asked my local senior engineer, and his advice was to create separate Cucumber tests for each scenario I intended to create. My plan was to write 6 scenarios in the long-term for this feature, and I really didn&rsquo;t want to turn these very similar tests with beautifully reusable steps into 6 features.</p>

<p>Then it hit me: Cucumber is open source. I found the source <a href="https://github.com/cucumber/cucumber-cpp">on Github</a> and started looking through <a href="https://github.com/cucumber/cucumber-cpp/tree/master/examples/">the example code</a>. It was there that I discovered <a href="https://github.com/cucumber/cucumber-cpp/tree/master/examples/FeatureShowcase/tag">tags</a>. Tags were the solution to my problem.</p>

<p>``` cucumber DoStuff.feature
Feature: Do that thing that we have to do</p>

<p>@first
Scenario: Do it my way
  &hellip;</p>

<p>@last
Scenario: Do it your way
  &hellip;
```</p>

<p>Using tags, I could label my scenarios with meaningful <code>@first</code> and <code>@last</code> tags to signify the beginning and end of my tests. The trick is to then add the required tags to my <code>BEFORE()</code> and <code>AFTER()</code> macro as such:</p>

<p>``` c++ DoStuff_StepDefinitions.cpp</p>

<h1>include &lt;cucumber-cpp/defs.hpp></h1>

<h1>include &lt;gtest/gtest.h></h1>

<h1>include &lt;mono/jit/jit.h></h1>

<p>const QString DOMAIN_NAME = &ldquo;bridge&rdquo;;</p>

<p>class Context
{
  // The static Mono object
  static MonoDomain *Domain;
}</p>

<p>BEFORE(&ldquo;@first&rdquo;) { Context::Domain = mono_jit_init(DOMAIN_NAME); }</p>

<p>AFTER(&ldquo;@last&rdquo;) { mono_jit_cleanup(Context::Domain); }</p>

<p>// &hellip;</p>

<p>```</p>

<p>Now my MonoDomain is only created <em>before</em> the scenario labeled <code>@first</code> and <em>after</em> the scenario labeled <code>@last</code>. Obviously, this isn&rsquo;t the cleanest fix imaginable, but it was the cleanest fix <em>available</em>. Whenever someone wants to add a new step to this test, they need to remember to move the <code>@last</code> tag to their scenario. However, I have the hope that it will be pretty obvious that the second scenario is no longer &ldquo;last&rdquo; when there is a third scenario following the &ldquo;last&rdquo; scenario. Anyway, it leaves me happy enough, since now my tests don&rsquo;t explode and I&rsquo;m able to reuse ~50% of the steps I had already written for the first scenario. I added a third scenario later on and 9 out of the 10 steps in the scenario were reused from the first and second scenario.</p>

<p>There are lots of other cool things you can do with Cucumber tags, like having multiple tags on objects. All tags that match <code>@first</code> will do one thing, but tags that match <code>@first</code> and <code>@second</code> can have multiple <code>BEFORE()</code> or <code>AFTER()</code> clauses.</p>
]]></content>
  </entry>
  
</feed>
