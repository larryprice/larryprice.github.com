<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sinatra | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/sinatra/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-08-02T20:32:12-04:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing automated emails with email-spec in Cucumber]]></title>
    <link href="http://larry-price.com/blog/2014/07/12/testing-automated-emails-with-email-spec-in-cucumber/"/>
    <updated>2014-07-12T07:36:33-04:00</updated>
    <id>http://larry-price.com/blog/2014/07/12/testing-automated-emails-with-email-spec-in-cucumber</id>
    <content type="html"><![CDATA[<p>Now that <a href="/blog/2014/07/07/deauthorizing-token-with-the-trello-client/">I send emails using Pony</a>, I want to be able to verify that the emails are being generated correctly. I also don&rsquo;t want to send real emails and have my tests check an inbox somewhere. I found a couple of solutions to do this, including <a href="https://github.com/johnmendonca/pony-test">pony-test</a> and <a href="https://github.com/bmabey/email-spec">email-spec</a>. Although pony-test fits my needs perfectly, the last commit was December 27, 2011 (2.5 years ago at the time of this post), and thus was using an outdated version of <a href="https://github.com/jnicklas/capybara">capybara</a> which I was unwilling to use. Fortunately, pony-spec is mostly just a fork of email-spec with all the non-Pony components ripped out.</p>

<p>I&rsquo;m going to be using Cucumber to test my emails, but email-spec also boasts compatibility with rspec and Turnip. To get started:</p>

<p><code>bash
$ gem install email-spec
</code></p>

<p>The developers of email-spec were kind enough to give us some free step definitions. If I was using rails, I could just type <code>rails generate email_spec:steps</code>, but since I&rsquo;m using Sinatra I opted just to copy-paste the file into my <code>step_definitions/</code> directory. You can find <code>email_steps.rb</code> <a href="https://raw.githubusercontent.com/bmabey/email-spec/master/lib/generators/email_spec/steps/templates/email_steps.rb">on Github</a>.</p>

<p>In <a href="/blog/2014/07/07/deauthorizing-token-with-the-trello-client/">my last post about small horses and emails</a>, I used the following code to send a confirmation email on signup:</p>

<p>``` ruby web.rb</p>

<h1>&hellip;</h1>

<p>post &lsquo;/signup&rsquo; do
  user = User.create! params</p>

<p>  url = &ldquo;#{request.base_url}/account/reset/#{user.generate_verification_hash}&rdquo;
  Pony.mail(</p>

<pre><code>to: user.email,
from: "MyApp Help Desk &lt;noreply@myapp.com&gt;",
subject: "MyApp Account Verification",
body: "A request has been made to verify your MyApp account (https://myapp.com)." +
      "If you made this request, go to " + url + ". If you did not make this request, ignore this email.",
html_body: haml(
  :verify_account_email,
  layout: false,
  locals: {
    email: user.email,
    date: DateTime.now.strftime("%H:%M:%S%P %B %d, %Y"),
    ip: request.ip,
    url: url
  }
)
</code></pre>

<p>  )
end</p>

<h1>&hellip;</h1>

<p>```</p>

<p>``` haml /views/verify_account_email.haml
%p
  Hello!
%p
  An account verification has been requested for your new <a href="https://myapp.com">MyApp</a> account.</p>

<p>%ul
  %li</p>

<pre><code>Username: #{locals[:email]}
</code></pre>

<p>  %li</p>

<pre><code>Time: #{locals[:date]}
</code></pre>

<p>  %li</p>

<pre><code>IP address: #{locals[:ip]}
</code></pre>

<p>%p
  If you made this request, click the link below or copy-paste the following URL into your browser to verify your account:</p>

<p>%p
  %a{href: &ldquo;#{locals[:url]}&rdquo;, alt: &ldquo;Verify&rdquo;, title: &ldquo;Click to verify account&rdquo;}</p>

<pre><code>#{locals[:url]}
</code></pre>

<p>%p
  If you did not request this new account, please ignore this email.</p>

<p>%p
  Sincerely,
  %br
  Team MyApp</p>

<p>%p
  This email account is not monitored and will not receive replies. For more information, contact <a href="mailto:connect@myapp.com"><a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x63;&#111;&#110;&#110;&#x65;&#x63;&#x74;&#64;&#109;&#121;&#x61;&#x70;&#x70;&#x2e;&#99;&#111;&#x6d;">&#99;&#111;&#110;&#110;&#x65;&#99;&#x74;&#64;&#109;&#121;&#97;&#112;&#x70;&#46;&#99;&#x6f;&#109;</a></a>.
```</p>

<p>Given the pre-defined steps from email-spec, testing that this email gets sent is a breeze. Adding a scenario to my feature file:</p>

<p>``` cucumber features/SignupConfirmation.feature
Feature: Signup Confirmation
  As a new user
  When I sign up
  I should receive a confirmation email</p>

<p>Background:
  Given a clear email queue
  When I go to the signup page
  And I fill in &ldquo;email&rdquo; with &ldquo;<a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#112;&#x72;&#101;&#122;&#x40;&#119;&#x68;&#105;&#116;&#x65;&#104;&#x6f;&#x75;&#115;&#x65;&#x2e;&#103;&#111;&#118;">&#x70;&#114;&#101;&#122;&#x40;&#119;&#104;&#x69;&#116;&#x65;&#x68;&#x6f;&#117;&#115;&#x65;&#46;&#103;&#x6f;&#x76;</a>&rdquo;
  And I fill in &ldquo;password&rdquo; with &ldquo;bunnies&rdquo;
  And I press &ldquo;Sign Up&rdquo;
  Then &ldquo;<a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#112;&#x72;&#101;&#122;&#x40;&#x77;&#104;&#x69;&#x74;&#x65;&#x68;&#111;&#117;&#115;&#x65;&#x2e;&#x67;&#x6f;&#118;">&#112;&#x72;&#101;&#x7a;&#64;&#119;&#104;&#105;&#116;&#101;&#104;&#x6f;&#117;&#x73;&#x65;&#46;&#103;&#x6f;&#x76;</a>&rdquo; should receive an email</p>

<p>Scenario: Receives email with correct contents
  When &ldquo;<a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#112;&#114;&#x65;&#x7a;&#64;&#x77;&#x68;&#105;&#116;&#x65;&#104;&#111;&#117;&#x73;&#x65;&#46;&#103;&#x6f;&#x76;">&#x70;&#114;&#x65;&#122;&#x40;&#119;&#x68;&#x69;&#116;&#x65;&#104;&#x6f;&#x75;&#x73;&#101;&#x2e;&#x67;&#111;&#118;</a>&rdquo; opens the email
  Then they should see the email delivered from &ldquo;MyApp Help Desk <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#110;&#x6f;&#x72;&#x65;&#112;&#x6c;&#x79;&#x40;&#x6d;&#121;&#x61;&#112;&#112;&#46;&#99;&#111;&#x6d;">&#x6e;&#x6f;&#x72;&#101;&#x70;&#x6c;&#121;&#x40;&#109;&#121;&#x61;&#x70;&#x70;&#x2e;&#x63;&#x6f;&#109;</a>&rdquo;
  And they should see &ldquo;MyApp Account Verification&rdquo; in the email subject
  And they should see &ldquo;Username: <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#112;&#x72;&#101;&#122;&#x40;&#x77;&#x68;&#x69;&#116;&#x65;&#x68;&#x6f;&#117;&#115;&#101;&#46;&#103;&#111;&#x76;">&#x70;&#x72;&#101;&#122;&#x40;&#x77;&#104;&#x69;&#x74;&#x65;&#104;&#x6f;&#x75;&#x73;&#101;&#46;&#x67;&#x6f;&#x76;</a>&rdquo; in the email body
  And they should see &ldquo;An account verification has been requested&rdquo;
```</p>

<p>That&rsquo;s it. Now we know that an email like the one above will be sent during signup. What we can&rsquo;t test here is that our SMTP server (or equivalent) is working, so in reality I&rsquo;m only testing that the email will attempt to send that looks like the one I test against.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sending emails with Pony and Sendgrid]]></title>
    <link href="http://larry-price.com/blog/2014/07/08/sending-emails-with-pony-and-sendgrid/"/>
    <updated>2014-07-08T05:53:26-04:00</updated>
    <id>http://larry-price.com/blog/2014/07/08/sending-emails-with-pony-and-sendgrid</id>
    <content type="html"><![CDATA[<p>It&rsquo;s incredible how easy it is to send emails through a web application, there&rsquo;s no wonder we get so much spam. Assuming we have a <a href="http://ruby-lang.org">ruby</a> app using <a href="http://sinatrarb.com">Sinatra</a>, <a href="http://adam.herokuapp.com/past/2008/11/2/pony_the_express_way_to_send_email_from_ruby/">Pony</a> is one of the easiest ways to get started with your own spam empire.</p>

<p>Installation is, as always, trivial with ruby. Install the gem with <code>gem install pony</code> or add <code>gem pony</code> to your <code>Gemfile</code> and run <code>bundle install</code>.</p>

<p>I like to configure Pony in my application&rsquo;s <code>configure</code> block. I could also add it to my <code>config.ru</code>, but I like to keep that file as tiny as posible to avoid having configuration code all over the place.</p>

<p>``` ruby web.rb</p>

<h1>&hellip;</h1>

<p>require &lsquo;pony&rsquo;
require &lsquo;sinatra/base&rsquo;</p>

<p>class Application &lt; Sinatra::Base
  configure do</p>

<pre><code># ...

Pony.options = {
  :via =&gt; :smtp,
  :via_options =&gt; {
    :address =&gt; 'smtp.sendgrid.net',
    :port =&gt; '587',
    :domain =&gt; 'myapp.com',
    :user_name =&gt; ENV['SENDGRID_USERNAME'],
    :password =&gt; ENV['SENDGRID_PASSWORD'],
    :authentication =&gt; :plain,
    :enable_starttls_auto =&gt; true
  }
}
</code></pre>

<p>  end</p>

<p>  # &hellip;
end
```</p>

<p>This block tells Pony to use the <a href="http://sendgrid.com/">SendGrid</a> server to send mail, use the &ldquo;myapp.com&rdquo; HELO domain, and dig up the username and password fields from my environment.</p>

<p>If you&rsquo;re using <a href="https://heroku.com">Heroku</a> to host your application, you can <a href="https://addons.heroku.com/sendgrid">sign up for a SendGrid account through your Heroku app</a>, which gives you instant access to your SendGrid account. The <code>username</code> and <code>password</code> field you need to fill in your environment are automatically populated in your Heroku config, which you can view by running <code>heroku config</code> for your application. The free account gets you up to 200 emails a day.</p>

<p>Since I might have multiple developers working in my source code and testing the email-sending functionality, I have all the developers <a href="https://sendgrid.com/user/signup">sign up for their own free SendGrid account</a>. This should help to alleviate some of the email volume from any particular account while developing. After signing up, it took my account nearly 4 hours to be &ldquo;provisioned&rdquo; (see: approved) by the SendGrid team. Once you&rsquo;re approved you can start sending emails using your developer account credentials. I stick my username/password in my local <code>.env</code> file (another reason to make sure you&rsquo;re not storing your environment on your server or in your git repo).</p>

<p>So let&rsquo;s actually send an email. Let&rsquo;s create a route that sends an email to verify a new user account; I&rsquo;ll take some liberties by saying we have a <code>User</code> model defined already that generates a signup verification hash. I can tell pony to send a plaintext body through the <code>body</code> option and an HTML body through the <code>html_body</code> option.</p>

<p>``` ruby web.rb</p>

<h1>&hellip;</h1>

<p>post &lsquo;/signup&rsquo; do
  user = User.create! params</p>

<p>  url = &ldquo;#{request.base_url}/account/reset/#{user.generate_verification_hash}&rdquo;
  Pony.mail(</p>

<pre><code>to: user.email,
from: "MyApp Help Desk &lt;noreply@myapp.com&gt;",
subject: "MyApp Account Verification",
body: "A request has been made to verify your MyApp account (https://myapp.com)." +
      "If you made this request, go to " + url + ". If you did not make this request, ignore this email.",
html_body: haml(
  :verify_account_email,
  layout: false,
  locals: {
    email: user.email,
    date: DateTime.now.strftime("%H:%M:%S%P %B %d, %Y"),
    ip: request.ip,
    url: url
  }
)
</code></pre>

<p>  )
end
```</p>

<p>``` haml views/verify_account_email.rb
%p
  Hello!
%p
  An account verification has been requested for your new <a href="https://myapp.com">MyApp</a> account.</p>

<p>%ul
  %li</p>

<pre><code>Username: #{locals[:email]}
</code></pre>

<p>  %li</p>

<pre><code>Time: #{locals[:date]}
</code></pre>

<p>  %li</p>

<pre><code>IP address: #{locals[:ip]}
</code></pre>

<p>%p
  If you made this request, click the link below or copy-paste the following URL into your browser to verify your account:</p>

<p>%p
  %a{href: &ldquo;#{locals[:url]}&rdquo;, alt: &ldquo;Verify&rdquo;, title: &ldquo;Click to verify account&rdquo;}</p>

<pre><code>#{locals[:url]}
</code></pre>

<p>%p
  If you did not request this new account, please ignore this email.</p>

<p>%p
  Sincerely,
  %br
  Team MyApp</p>

<p>%p
  This email account is not monitored and will not receive replies. For more information, contact <a href="mailto:connect@myapp.com"><a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x63;&#x6f;&#x6e;&#x6e;&#x65;&#x63;&#116;&#x40;&#x6d;&#121;&#97;&#x70;&#x70;&#x2e;&#99;&#x6f;&#x6d;">&#99;&#111;&#x6e;&#110;&#x65;&#99;&#x74;&#x40;&#x6d;&#121;&#x61;&#112;&#x70;&#46;&#99;&#111;&#109;</a></a>.
```</p>

<p>When you have a user hit this route, an email will be sent to the user with the given subject, to, from, and body fields using the configuration parameters given in the previous <code>configure</code> block. Fast, easy, and, best of all, no <code>sendmail</code> configuration.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using sqlite on Heroku]]></title>
    <link href="http://larry-price.com/blog/2014/03/29/using-sqlite-on-heroku/"/>
    <updated>2014-03-29T11:16:06-04:00</updated>
    <id>http://larry-price.com/blog/2014/03/29/using-sqlite-on-heroku</id>
    <content type="html"><![CDATA[<p>Or rather, &ldquo;Not Using sqlite on Heroku.&rdquo;</p>

<p><a href="//heroku.com">Heroku</a> does not support <a href="//sqlite.org">sqlite</a>. That doesn&rsquo;t mean we have to stop using sqlite in development, but it does mean we need to put in some workarounds to support our deployment environment. The rest of this article will use <a href="//ruby-lang.org">ruby</a> and <a href="//sinatrarb.com">Sinatra</a>.</p>

<p>Assuming you have a heroku app deployed and you have sqlite already working locally, this only takes a few steps. First we need to add a SQL database to our heroku app. From the project directory, we&rsquo;ll add the <a href="//addons.heroku.com/heroku-postgresql">heroku-postgresql</a> addon to our app.</p>

<p><code>bash
$ heroku addons:add heroku-postgresql:dev
</code></p>

<p>The <code>dev</code> piece of this command tells heroku we want the small, free database. This database supports up to 10,000 rows and has a 99.5% uptime. Best of all: it&rsquo;s free. Other options have you pay $9/mo for 10,000,000 rows or $50+ for Unlimited usage. I recommend you start small.</p>

<p>Hopefully you got some success statements after adding heroku-postgresql. They should have included some new environment variables, which are links to your new Postgres database. Record these; we&rsquo;ll use them a little later.</p>

<p>Now we need to set up the back-end to be able to access a Postgres database when necessary. Hopefully you&rsquo;re using a decent abstraction library in your app that can access any SQL database. For ruby, I find <a href="//www.sequel.rubyforge.org/">Sequel</a> to be sufficient.</p>

<p>In our Gemfile, we&rsquo;ve probably already included the sqlite gem for use in our local environment. We can go ahead and move that into a <code>development</code> block, and we need to add the <code>pg</code> gem to either <code>production</code> or the global block.</p>

<p>``` ruby Gemfile
source &ldquo;<a href="https://rubygems.org">https://rubygems.org</a>&rdquo;</p>

<p>ruby &lsquo;2.1.0&rsquo;</p>

<p>gem &lsquo;bundler&rsquo;
gem &lsquo;rake&rsquo;
gem &lsquo;sinatra&rsquo;
gem &lsquo;haml&rsquo;
gem &lsquo;sequel&rsquo;</p>

<p>group :production do
  gem &lsquo;pg&rsquo;
end</p>

<p>group :development do
  gem &lsquo;sqlite3&rsquo;
end
```</p>

<p>Heroku sets <code>ENV['RACK_ENV']</code> to &ldquo;production&rdquo; for us, which means that the pg gem should get picked up the next time we deploy. Now we need to tell our app which database to use in which situation.</p>

<p>One of the easiest places to make this decision is in Sinatra&rsquo;s <code>configure</code> block. I keep my local db in an environment variable called <code>LOCAL_DATABASE_URL</code>. This is where you use the environment variable heroku set for you when you set up your Postgres database; mine was called <code>HEROKU_POSTGRESQL_MAROON_URL</code>.</p>

<p>``` ruby web.rb
class App &lt; Sinatra::Base
  configure :production do</p>

<pre><code>Sequel.connect ENV['HEROKU_POSTGRESQL_MAROON_URL']
</code></pre>

<p>  end</p>

<p>  configure :development do</p>

<pre><code>Sequel.connect ENV['LOCAL_DATABASE_URL']
</code></pre>

<p>  end
end
```</p>

<p>This works because the default environment is &ldquo;development.&rdquo; Test locally, and then we can deploy.</p>

<p><code>bash
$ git push heroku master
</code></p>

<p>And enjoy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Foreman to Create an Upstart Service]]></title>
    <link href="http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service/"/>
    <updated>2013-08-31T17:05:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service</id>
    <content type="html"><![CDATA[<p>I just finished my first attempt at deploying a web app to run automatically in the background on a friend&rsquo;s server. Pretty easy, really. The first thing I did was install <a href="https://github.com/ddollar/foreman">foreman</a>. Assuming you have ruby and rubygems installed:</p>

<p><code>bash
$ sudo gem install foreman
</code></p>

<p>Next I needed to give foreman the commands to start my app. I created a file in the root of my project directory called &lsquo;Procfile&rsquo; and gave it the steps I would run to start my app manually. For the sake of simplicity, let&rsquo;s say I run my app pretty barebones:</p>

<p><code>bash Procfile
web: bundle exec rackup
</code></p>

<p>Now when I run <code>foreman start</code>, foreman will use <a href="http://bundler.io/">Bundler</a> to execute rackup with the correct gems in my Gemfile. Now exporting upstart config files is pretty easy.</p>

<p><code>bash
$ sudo foreman export upstart --app=MyApp --user=root /etc/init
</code></p>

<p>That command creates the .conf files needed for upstart to control the service called &lsquo;MyApp&rsquo; as the user &lsquo;root.&rsquo; It puts all the .conf files in <code>/etc/init</code> (which is where Ubuntu puts such things) and will create a default log directory in <code>/var/log/MyApp</code>. Now I can control my service by running <code>service MyApp start</code>, <code>service MyApp stop</code>, <code>service MyApp restart</code>, and <code>service MyApp status</code>. Hooray for me.</p>

<p>But I need to run my app in two ways: in dev mode on a local port with my dev database, and I need to run it in production mode using port 80 and the production database. I&rsquo;ve also heard that using <a href="https://en.wikipedia.org/wiki/WEBrick">webrick</a> (the default server installed with rackup) is great for develpment, but I should be using something else for my production server. So I made some config files for foreman:</p>

<p><code>bash development.env
RACK_ENV=development
PORT=9292
SERVER=rackup
</code></p>

<p><code>bash production.env
RACK_ENV=production
PORT=80
SERVER=unicorn
</code></p>

<p>And I change my Procfile to:</p>

<p><code>bash Procfile
web: bundle exec $SERVER -p $PORT -E $RACK_ENV
</code></p>

<p>Ridiculously configured. Now when I run <code>foreman start</code>, it will error out. I need to specify my environment file:</p>

<p><code>bash
$ foreman start -e production.env
</code></p>

<p>Now foreman will use Bundler to startup the server specified in <code>$SERVER</code>, run the app on port <code>$PORT</code> (-p), and will pass through the environment listed as <code>$RACK_ENV</code> to my application (-E), allowing my app to do whatever configuration it does given the current environment. Power to the people.</p>

<p><a href="http://michaelvanrooijen.com/articles/2011/06/08-managing-and-monitoring-your-ruby-application-with-foreman-and-upstart/">I found that this guy</a> does a lot more complicated stuff with Foreman, if you need more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the Futility of Man and Trying to Divide a Sinatra App into Separate Controllers]]></title>
    <link href="http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers/"/>
    <updated>2013-08-26T22:35:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers</id>
    <content type="html"><![CDATA[<p>Oh, <a href="http://www.sinatrarb.com/">Sinatra</a>. You&rsquo;re oh-so-very dear to me. You made it so easy for me to write my <a href="http://capitalpunishment.herokuapp.com">first</a> <a href="http://pokephile.herokuapp.com">web</a> apps. All I had to do was write a couple routes and throw together a few HTML-like files and I had a web app. I used pattern matching to reduce the web-facing code for <a href="https://github.com/larryprice/CapitalPunishment">Capital Punishment</a> from ~500 lines of code to &lt;100 lines of code. You are perfect for writing small-time web applications.</p>

<p>But what about large web applications? What about a web app that has normal users and admin users, makes lots of database reads and writes (my previous apps only did reads from a user-facing perspective), and has to be able to show the history of everything, forever, to the authorized users who request it?</p>

<p>You see, Sinatra is kind of an <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC framework</a>, but not exactly. In Sinatra, you have Views (your HTML inter-mixed with Ruby code in your desired DSL) and you have Controllers (each of your routes). When a database is involved, you can use something like <a href="https://github.com/bmizerany/sinatra-activerecord">ActiveRecord</a> or <a href="http://mongoid.org/en/mongoid/index.html">Mongoid</a> or <a href="http://datamapper.org/">DataMapper</a> and you have yourself Models.</p>

<p>So every route is kind of a Controller. Every. Route. In Capital Punishment, there were once 8 routes (there are now 7). In the project I&rsquo;ve been working on recently, there are currently 56 routes. 56 routes in the language described above means I kind of have 56 controllers.</p>

<p>That&rsquo;s been pretty overwhelming, especially since the traditional way of creating routes in Sinatra is to shove them all in the same file. There are a few ways I could think of to address this. The way we chose six months ago (for better or worse) was found <a href="http://stackoverflow.com/questions/5877000/what-is-a-controller-in-sinatra">on StackOverflow</a>, and involves creating a bunch of different files where you shove all related routes. So you get this situation:</p>

<p>``` ruby app.rb
class App &lt; Sinatra::Base
end</p>

<p>require_relative &lsquo;controllers/helpers&rsquo;</p>

<p>Dir.glob(&ldquo;#{File.dirname(<strong>FILE</strong>)}/controllers/*.rb&rdquo;).each do |file|
  require file.chomp(File.extname(file))
end</p>

<p>class App
  get &lsquo;/&rsquo; do</p>

<pre><code>erb :home
</code></pre>

<p>  end
end
```</p>

<p>``` ruby controllers/reports_controller.rb
class App
  get &lsquo;/reports/user_bills&rsquo; do</p>

<pre><code>erb :user_bills_report
</code></pre>

<p>  end
  &hellip;
end
```</p>

<p>And so on and so forth. This works fine for a while, but we&rsquo;ve ended up with 13 &ldquo;controller&rdquo; files, many of which are not trivial. This also makes the App class quite large since its controllers handle most of the logic for the app. This also doesn&rsquo;t enforce any kind of URL-naming logic, so if a developer is working hard (s)he may create both <code>/reports/user_bills</code> and <code>user_info_reports</code> without realizing the inconsistency (s)he just injected into the system.</p>

<p>In hindsight, this method is not perfect. I think that the Rails method of individual controllers is significantly better for large apps. Some people have been using other methods for trying to make Sinatra more MVC, such as <a href="https://github.com/jorrizza/sinatra-mvc">sinatra-mvc</a>. To be frank, sinatra-mvc pretty much does the same thing we&rsquo;ve done, but with more structure.</p>

<p>I think what I&rsquo;ve learned is that you should use a tool for its intended purpose. Sinatra was written to quickly create web apps in Ruby with minimal effort. Once you have more than 10-15 routes, you should reconsider whether your app can still be called &ldquo;minimal effort.&rdquo; Sinatra may fly you to the moon, but you&rsquo;re unlikely to see what spring is like on Jupiter or Mars.</p>
]]></content>
  </entry>
  
</feed>
