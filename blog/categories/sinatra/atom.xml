<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sinatra | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/sinatra/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-05-14T20:58:07-04:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using sqlite on Heroku]]></title>
    <link href="http://larry-price.com/blog/2014/03/29/using-sqlite-on-heroku/"/>
    <updated>2014-03-29T11:16:06-04:00</updated>
    <id>http://larry-price.com/blog/2014/03/29/using-sqlite-on-heroku</id>
    <content type="html"><![CDATA[<p>Or rather, &ldquo;Not Using sqlite on Heroku.&rdquo;</p>

<p><a href="//heroku.com">Heroku</a> does not support <a href="//sqlite.org">sqlite</a>. That doesn&rsquo;t mean we have to stop using sqlite in development, but it does mean we need to put in some workarounds to support our deployment environment. The rest of this article will use <a href="//ruby-lang.org">ruby</a> and <a href="//sinatrarb.com">Sinatra</a>.</p>

<p>Assuming you have a heroku app deployed and you have sqlite already working locally, this only takes a few steps. First we need to add a SQL database to our heroku app. From the project directory, we&rsquo;ll add the <a href="//addons.heroku.com/heroku-postgresql">heroku-postgresql</a> addon to our app.</p>

<p><code>bash
$ heroku addons:add heroku-postgresql:dev
</code></p>

<p>The <code>dev</code> piece of this command tells heroku we want the small, free database. This database supports up to 10,000 rows and has a 99.5% uptime. Best of all: it&rsquo;s free. Other options have you pay $9/mo for 10,000,000 rows or $50+ for Unlimited usage. I recommend you start small.</p>

<p>Hopefully you got some success statements after adding heroku-postgresql. They should have included some new environment variables, which are links to your new Postgres database. Record these; we&rsquo;ll use them a little later.</p>

<p>Now we need to set up the back-end to be able to access a Postgres database when necessary. Hopefully you&rsquo;re using a decent abstraction library in your app that can access any SQL database. For ruby, I find <a href="//www.sequel.rubyforge.org/">Sequel</a> to be sufficient.</p>

<p>In our Gemfile, we&rsquo;ve probably already included the sqlite gem for use in our local environment. We can go ahead and move that into a <code>development</code> block, and we need to add the <code>pg</code> gem to either <code>production</code> or the global block.</p>

<p>``` ruby Gemfile
source &ldquo;<a href="https://rubygems.org">https://rubygems.org</a>&rdquo;</p>

<p>ruby &lsquo;2.1.0&rsquo;</p>

<p>gem &lsquo;bundler&rsquo;
gem &lsquo;rake&rsquo;
gem &lsquo;sinatra&rsquo;
gem &lsquo;haml&rsquo;
gem &lsquo;sequel&rsquo;</p>

<p>group :production do
  gem &lsquo;pg&rsquo;
end</p>

<p>group :development do
  gem &lsquo;sqlite3&rsquo;
end
```</p>

<p>Heroku sets <code>ENV['RACK_ENV']</code> to &ldquo;production&rdquo; for us, which means that the pg gem should get picked up the next time we deploy. Now we need to tell our app which database to use in which situation.</p>

<p>One of the easiest places to make this decision is in Sinatra&rsquo;s <code>configure</code> block. I keep my local db in an environment variable called <code>LOCAL_DATABASE_URL</code>. This is where you use the environment variable heroku set for you when you set up your Postgres database; mine was called <code>HEROKU_POSTGRESQL_MAROON_URL</code>.</p>

<p>``` ruby web.rb
class App &lt; Sinatra::Base
  configure :production do</p>

<pre><code>Sequel.connect ENV['HEROKU_POSTGRESQL_MAROON_URL']
</code></pre>

<p>  end</p>

<p>  configure :development do</p>

<pre><code>Sequel.connect ENV['LOCAL_DATABASE_URL']
</code></pre>

<p>  end
end
```</p>

<p>This works because the default environment is &ldquo;development.&rdquo; Test locally, and then we can deploy.</p>

<p><code>bash
$ git push heroku master
</code></p>

<p>And enjoy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Foreman to Create an Upstart Service]]></title>
    <link href="http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service/"/>
    <updated>2013-08-31T17:05:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service</id>
    <content type="html"><![CDATA[<p>I just finished my first attempt at deploying a web app to run automatically in the background on a friend&rsquo;s server. Pretty easy, really. The first thing I did was install <a href="https://github.com/ddollar/foreman">foreman</a>. Assuming you have ruby and rubygems installed:</p>

<p><code>bash
$ sudo gem install foreman
</code></p>

<p>Next I needed to give foreman the commands to start my app. I created a file in the root of my project directory called &lsquo;Procfile&rsquo; and gave it the steps I would run to start my app manually. For the sake of simplicity, let&rsquo;s say I run my app pretty barebones:</p>

<p><code>bash Procfile
web: bundle exec rackup
</code></p>

<p>Now when I run <code>foreman start</code>, foreman will use <a href="http://bundler.io/">Bundler</a> to execute rackup with the correct gems in my Gemfile. Now exporting upstart config files is pretty easy.</p>

<p><code>bash
$ sudo foreman export upstart --app=MyApp --user=root /etc/init
</code></p>

<p>That command creates the .conf files needed for upstart to control the service called &lsquo;MyApp&rsquo; as the user &lsquo;root.&rsquo; It puts all the .conf files in <code>/etc/init</code> (which is where Ubuntu puts such things) and will create a default log directory in <code>/var/log/MyApp</code>. Now I can control my service by running <code>service MyApp start</code>, <code>service MyApp stop</code>, <code>service MyApp restart</code>, and <code>service MyApp status</code>. Hooray for me.</p>

<p>But I need to run my app in two ways: in dev mode on a local port with my dev database, and I need to run it in production mode using port 80 and the production database. I&rsquo;ve also heard that using <a href="https://en.wikipedia.org/wiki/WEBrick">webrick</a> (the default server installed with rackup) is great for develpment, but I should be using something else for my production server. So I made some config files for foreman:</p>

<p><code>bash development.env
RACK_ENV=development
PORT=9292
SERVER=rackup
</code></p>

<p><code>bash production.env
RACK_ENV=production
PORT=80
SERVER=unicorn
</code></p>

<p>And I change my Procfile to:</p>

<p><code>bash Procfile
web: bundle exec $SERVER -p $PORT -E $RACK_ENV
</code></p>

<p>Ridiculously configured. Now when I run <code>foreman start</code>, it will error out. I need to specify my environment file:</p>

<p><code>bash
$ foreman start -e production.env
</code></p>

<p>Now foreman will use Bundler to startup the server specified in <code>$SERVER</code>, run the app on port <code>$PORT</code> (-p), and will pass through the environment listed as <code>$RACK_ENV</code> to my application (-E), allowing my app to do whatever configuration it does given the current environment. Power to the people.</p>

<p><a href="http://michaelvanrooijen.com/articles/2011/06/08-managing-and-monitoring-your-ruby-application-with-foreman-and-upstart/">I found that this guy</a> does a lot more complicated stuff with Foreman, if you need more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the Futility of Man and Trying to Divide a Sinatra App into Separate Controllers]]></title>
    <link href="http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers/"/>
    <updated>2013-08-26T22:35:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers</id>
    <content type="html"><![CDATA[<p>Oh, <a href="http://www.sinatrarb.com/">Sinatra</a>. You&rsquo;re oh-so-very dear to me. You made it so easy for me to write my <a href="http://capitalpunishment.herokuapp.com">first</a> <a href="http://pokephile.herokuapp.com">web</a> apps. All I had to do was write a couple routes and throw together a few HTML-like files and I had a web app. I used pattern matching to reduce the web-facing code for <a href="https://github.com/larryprice/CapitalPunishment">Capital Punishment</a> from ~500 lines of code to &lt;100 lines of code. You are perfect for writing small-time web applications.</p>

<p>But what about large web applications? What about a web app that has normal users and admin users, makes lots of database reads and writes (my previous apps only did reads from a user-facing perspective), and has to be able to show the history of everything, forever, to the authorized users who request it?</p>

<p>You see, Sinatra is kind of an <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC framework</a>, but not exactly. In Sinatra, you have Views (your HTML inter-mixed with Ruby code in your desired DSL) and you have Controllers (each of your routes). When a database is involved, you can use something like <a href="https://github.com/bmizerany/sinatra-activerecord">ActiveRecord</a> or <a href="http://mongoid.org/en/mongoid/index.html">Mongoid</a> or <a href="http://datamapper.org/">DataMapper</a> and you have yourself Models.</p>

<p>So every route is kind of a Controller. Every. Route. In Capital Punishment, there were once 8 routes (there are now 7). In the project I&rsquo;ve been working on recently, there are currently 56 routes. 56 routes in the language described above means I kind of have 56 controllers.</p>

<p>That&rsquo;s been pretty overwhelming, especially since the traditional way of creating routes in Sinatra is to shove them all in the same file. There are a few ways I could think of to address this. The way we chose six months ago (for better or worse) was found <a href="http://stackoverflow.com/questions/5877000/what-is-a-controller-in-sinatra">on StackOverflow</a>, and involves creating a bunch of different files where you shove all related routes. So you get this situation:</p>

<p>``` ruby app.rb
class App &lt; Sinatra::Base
end</p>

<p>require_relative &lsquo;controllers/helpers&rsquo;</p>

<p>Dir.glob(&ldquo;#{File.dirname(<strong>FILE</strong>)}/controllers/*.rb&rdquo;).each do |file|
  require file.chomp(File.extname(file))
end</p>

<p>class App
  get &lsquo;/&rsquo; do</p>

<pre><code>erb :home
</code></pre>

<p>  end
end
```</p>

<p>``` ruby controllers/reports_controller.rb
class App
  get &lsquo;/reports/user_bills&rsquo; do</p>

<pre><code>erb :user_bills_report
</code></pre>

<p>  end
  &hellip;
end
```</p>

<p>And so on and so forth. This works fine for a while, but we&rsquo;ve ended up with 13 &ldquo;controller&rdquo; files, many of which are not trivial. This also makes the App class quite large since its controllers handle most of the logic for the app. This also doesn&rsquo;t enforce any kind of URL-naming logic, so if a developer is working hard (s)he may create both <code>/reports/user_bills</code> and <code>user_info_reports</code> without realizing the inconsistency (s)he just injected into the system.</p>

<p>In hindsight, this method is not perfect. I think that the Rails method of individual controllers is significantly better for large apps. Some people have been using other methods for trying to make Sinatra more MVC, such as <a href="https://github.com/jorrizza/sinatra-mvc">sinatra-mvc</a>. To be frank, sinatra-mvc pretty much does the same thing we&rsquo;ve done, but with more structure.</p>

<p>I think what I&rsquo;ve learned is that you should use a tool for its intended purpose. Sinatra was written to quickly create web apps in Ruby with minimal effort. Once you have more than 10-15 routes, you should reconsider whether your app can still be called &ldquo;minimal effort.&rdquo; Sinatra may fly you to the moon, but you&rsquo;re unlikely to see what spring is like on Jupiter or Mars.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pushing an Application to Heroku that Uses Ruby and Mongo]]></title>
    <link href="http://larry-price.com/blog/2013/01/20/pushing-an-application-to-heroku-that-uses-ruby-and-mongo/"/>
    <updated>2013-01-20T11:55:00-05:00</updated>
    <id>http://larry-price.com/blog/2013/01/20/pushing-an-application-to-heroku-that-uses-ruby-and-mongo</id>
    <content type="html"><![CDATA[<p><em>This is Part 3 in a multi-part series to detail the creation of a &ldquo;simple&rdquo; project combining <a href="http://www.ruby-lang.org/">Ruby</a>, <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://rspec.info/">RSpec</a>, <a href="http://www.sinatrarb.com/">Sinatra</a>, and <a href="https://github.com/jnicklas/capybara">Capybara</a> in preperation for a larger-scale side project set to begin January 2013. For more in this series, see the <a href="/blog/categories/pokephile">Pokephile category</a>. Part 4 of this series details moving from a development environment to a production environment using <a href="http://heroku.com/">Heroku</a>. The code for this side-project is located <a href="https://github.com/larryprice/Pokephile">on Github</a>, and the final product can be found <a href="http://pokephile.herokuapp.com">here</a>.</em></p>

<p><a href="http://heroku.com/">Heroku</a> is a hosting service for different types of web applications. The best thing about Heroku is it&rsquo;s free, you get a decent subdomain for your application, and there&rsquo;s no spam email. Go ahead and <a href="http://api.heroku.com/signup">sign up</a> if you don&rsquo;t already have an account.</p>

<p>Now we need the Heroku Toolbelt. I&rsquo;ll illustrate for Ubuntu 12.10, but there&rsquo;s also <a href="https://toolbelt.heroku.com/">documentation for installing on any OS</a>.</p>

<p><code>bash
$ wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh | sh
</code></p>

<p>The toolbelt installs some Heroku-specific applications in addition to ensuring you have Foreman and <a href="http://git-scm.com/">Git</a> on your system. Now it&rsquo;s time to tell the Heroku Toolbelt who we are.</p>

<p><code>bash Step 3 - Modified Excerpt from the Heroku Getting Started guide
$ heroku login
Enter your Heroku credentials.
Email: larry@example.com
Password:
Could not find an existing public key.
Would you like to generate one? [Yn]
Generating new SSH public key.
Uploading ssh public key /home/larry/.ssh/id_rsa.pub
</code></p>

<p>In order for Heroku to figure out what ruby gems are needed to run your application, you need to specify a Gemfile. It&rsquo;s wise to specify a specific version of Ruby, and it&rsquo;s also a good idea to keep the gems' versions close to the state you developed with. For the <a href="/blog/categories/pokephile">Pokephile</a> application created in this series, this is my Gemfile:</p>

<p>``` ruby project/Gemfile
source :rubygems</p>

<p>ruby &lsquo;1.9.3&rsquo;</p>

<p>gem &lsquo;sinatra&rsquo;, &lsquo;~>1.3.2&rsquo;
gem &lsquo;haml&rsquo;, &lsquo;~>3.1.6&rsquo;
gem &lsquo;mongoid&rsquo;, &lsquo;~>3.0.14&rsquo;</p>

<p>group :development, :test do</p>

<pre><code>gem 'capybara', '~&gt;2.0.1'
gem 'rspec', '~&gt;2.11.0'
gem 'nokogiri', '~&gt;1.5.5'
</code></pre>

<p>end
```</p>

<p>First I specify a source for my gems: &lsquo;rubygems&rsquo; defaults to &ldquo;<a href="http://rubygems.org">http://rubygems.org</a>&rdquo; and hasn&rsquo;t failed me yet. Next I specify that I want to use Ruby 1.9.3, a necessity because Mongoid 3.x doesn&rsquo;t work correctly with 1.9.2. The versions of the first three gems were chosen by typing the following in the command line to determine which version I had installed on my machine:</p>

<p><code>bash
$ gem query | grep 'sinatra\|haml\|mongoid'
haml (3.1.7, 3.1.6)
mongoid (3.0.17, 3.0.15, 3.0.14)
sinatra (1.3.3, 1.3.2)
sinatra-contrib (1.3.2)
sinatra-reloader (1.0)
</code></p>

<p>The &lsquo;~>&rsquo; operator tells Bundler to use greater-than-equal but stop before next highest version. So, for Sinatra &lsquo;~>1.3.2&rsquo; means that Bundler will accept anything greater-than-or-equal-to &lsquo;1.3.2&rsquo; and less than &lsquo;1.4.0.&rsquo; I tend to rely on the &lsquo;~>&rsquo; operator so I can be sure no APIs are changed in my gems.</p>

<p>The next block is a conditional checking in which environment the gems are being installed. This defaults to :development if none is specified. I put the gems used for testing in this block since they&rsquo;re not needed to run the application, but a developer/tester would need these to run the tests.</p>

<p>For this Gemfile to be meaningful, we need to use a program called <a href="http://gembundler.com/">Bundler</a> to &ldquo;bundle&rdquo; the gems and their dependencies in a Gemfile.lock file.</p>

<p><code>bash
$ pwd
project/
$ sudo apt-get install bundler
...
$ bundle install
...
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
</code></p>

<p>Running bundler will create a Gemfile.lock file and make sure your system has the specified gems. If some gems are missing or need new versions to be installed, bundler will ask the user for their password to get the required gems.</p>

<p>The next step for setting things up is to set up Git. If your application is already using Git, you only need to commit all files to verify that the Gemfile and Gemfile.lock make it into the repository.</p>

<p><code>bash
$ cd project/
$ git init
$ git add .
$ git commit -m "Initial commit."
</code></p>

<p>Now we create a Heroku project and give it a meaningful name. If you can&rsquo;t think of a meaningful name, use &lsquo;heroku create&rsquo; and Heroku will come up with something for you.</p>

<p><code>bash
$ heroku create meaningful-name
Creating meaningful-name... done, stack is cedar
http://meaningful-name.herokuapp.com/ | git@heroku.com:meaningful-name.git
Git remote heroku added
</code></p>

<p>We&rsquo;re almost there. Because we included accessing Mongo databases in our application, we have to take care of that on the web. The easiest way to do that is using a Heroku Add-on. At this time, there are two major Heroku Add-ons for Mongo databases: <a href="https://addons.heroku.com/mongolab">MongoLab</a> and <a href="https://addons.heroku.com/mongohq">MongoHQ</a>. Both services have a starter service for $0/month, which is pretty awesome in my opinion. I flipped a coin and picked MongoLab for this application. Adding the add-on to our project:</p>

<p><code>bash
$ heroku addons:add mongolab:starter
</code></p>

<p>If you haven&rsquo;t already, Heroku will ask you to &ldquo;verify your account&rdquo; before continuing. This means that you have to put in some credit card information. Note that you will not be charged, I guess Heroku just wants some indication that you might eventually pay for something. After you put in your credit card information, you may need to run the above command again.</p>

<p>Now that MongoLab is set up on the server-side, we need to tell Mongoid how to connect to that server. The following command will give you the environment variable needed to connect to the server:</p>

<p><code>bash
$ heroku config | grep MONGOLAB_URI
</code></p>

<p>Now we update our mongoid.yml file to use that string:</p>

<p>``` yml project/mongoid.yml
development:
  sessions:</p>

<pre><code>default:
  database: dev
  hosts:
    - localhost
</code></pre>

<p>  options:</p>

<p>test:
  sessions:</p>

<pre><code>default:
  database: test
  hosts:
    - localhost
</code></pre>

<p>production:
  sessions:</p>

<pre><code>default:
  uri: &lt;%= ENV['MONGOLAB_URI'] %&gt;
  options:
    skip_version_check: true
    safe: true
</code></pre>

<p>```</p>

<p>Because of the way my application works, I want to prepopulate the database with some Pokemon.</p>

<p><code>`` bash
$ export MONGOLAB_URI=</code>heroku config | grep MONGOLAB_URI | cut -c 15-`
$ pwd
project/
$ cd tools/populate
$ irb</p>

<blockquote><blockquote><p>require &lsquo;./populater&rsquo;
true
require &lsquo;mongoid&rsquo;
true
Mongoid.load! &lsquo;../../mongoid.yml&rsquo;, :production
{&ldquo;sessions&rdquo;=>{&ldquo;default&rdquo;=>{&ldquo;uri&rdquo;=>nil, &ldquo;options&rdquo;=>{&ldquo;skip_version_check&rdquo;=>true, &ldquo;safe&rdquo;=>true}}}}
Populater.new.add_pokemon 1000
nil
```</p></blockquote></blockquote>

<p>With the production database populated, we need to set an environment variable in our production application defining the environment.</p>

<p><code>bash
$ heroku config:add MONGOID_ENV=production
</code></p>

<p>Now that we&rsquo;ve made changes to the mongoid.yml file, we should commit again and push to Heroku.</p>

<p><code>bash
$ git commit -a -m "Updating mongoid.yml file for production"
...
$ git push heroku master
</code></p>

<p>And that&rsquo;s it! Check your Heroku URL to make sure everything looks okay and call it a day, or make some upgrades as I did for my <a href="http://pokephile.herokuapp.com">personal version of this project</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing a Sinatra App with Capybara]]></title>
    <link href="http://larry-price.com/blog/2013/01/19/testing-a-sinatra-app-with-capybara/"/>
    <updated>2013-01-19T12:20:00-05:00</updated>
    <id>http://larry-price.com/blog/2013/01/19/testing-a-sinatra-app-with-capybara</id>
    <content type="html"><![CDATA[<p><em>This is Part 3 in a multi-part series to detail the creation of a &ldquo;simple&rdquo; project combining <a href="http://www.ruby-lang.org/">Ruby</a>, <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://rspec.info/">RSpec</a>, <a href="http://www.sinatrarb.com/">Sinatra</a>, and <a href="https://github.com/jnicklas/capybara">Capybara</a> in preperation for a larger-scale side project set to begin January 2013. For more in this series, see the <a href="/blog/categories/pokephile">Pokephile category</a>. Part 3 of this series describes using Capybara to test a Sinatra application. The code for this side-project is located <a href="https://github.com/larryprice/Pokephile">on Github</a>, and the final product can be found <a href="http://pokephile.herokuapp.com">here</a>.</em></p>

<p>Now that <a href="/blog/2013/01/05/schemaless-databases-with-ruby-and-mongodb/">the database is populated</a> with data and I&rsquo;ve switched over to <a href="/blog/2013/01/05/moving-from-the-mongodb-ruby-driver-to-mongoid/">a simpler interface with Mongo</a>, I can actually start creating a UI. For simplicity&rsquo;s sake, I like to use Sinatra on small projects. Sinatra makes it easy to create a web application with minimal effort. With an emphasis on testing this <a href="/blog/categories/pokephile">series</a>, I want to be sure to throughly test my UI and any application integration. <a href="http://cukes.info/">Cucumber</a> is a brilliant DSL which allows a programmer to describe in plain English how an application should be behaving. The <a href="https://github.com/jnicklas/capybara">Capybara gem</a> is a Rack app that simulates running your application and performing basic user tasks, such as clicking a button, following a link, or, on a lower level, looking at your HTML source. Install Capybara like so:</p>

<p><code>bash
sudo gem install capybara
</code></p>

<p>Here&rsquo;s what I want my application to do:</p>

<ul>
<li>User is on home page.</li>
<li>User enters name of Pokemon and presses &lsquo;Search&rsquo;.</li>
<li>User is redirected to search page.</li>
<li>User can see some information about Pokemon.</li>
<li>User can repeat the search process.</li>
</ul>


<p>Error scenario:</p>

<ul>
<li>User enters garbage data.</li>
<li>User is redirected to search page.</li>
<li>User sees error message.</li>
<li>User can repeat search process.</li>
</ul>


<p>So I&rsquo;ll begin by writing my features. Cucumber syntax is meant to be readable by non-technical persons, so the &ldquo;code&rdquo; may look a bit odd. All Cucumber feature files are written something like this:</p>

<p>``` Cucumber
Feature: Viewer visits the Home Page
  In order to read the page
  As a viewer
  I want to see the home page of my app</p>

<p>Scenario: View the home page</p>

<pre><code>Given I am on the home page
Then I should see "Zowee, mama!" on the page
</code></pre>

<p>```</p>

<p>The &ldquo;Feature&rdquo; lines are not used in testing; they are simply to give some relevance to the file&rsquo;s feature and to attempt to prevent scope creep in the file. The &ldquo;Scenario&rdquo; lines are what&rsquo;s important. The first line is the test name, the &ldquo;Given&rdquo; line is the pre-condition, and the final line is what should be observed.</p>

<p>In reality, I have only one main feature: &ldquo;Search.&rdquo; One can argue that I also have a feature of &ldquo;seeing&rdquo; my home page and my search page, but those are both trivial cases, so for the purpose of this blog post, I&rsquo;ll skip such tests. Both my success and error case revolves around searching, and there&rsquo;s not really much else to do in the app. I have to create a directory for the cukes, and that directory is called &ldquo;features.&rdquo; I create such a directory in my &ldquo;project/tools/test&rdquo; directory and create a new file called &ldquo;search.feature.&rdquo; Now I&rsquo;ll write the feature:</p>

<p>``` Cucumber project/tools/test/features/search.feature
Feature: Viewer vists the page</p>

<pre><code>In order to search the page
As a visitor
I want to search for Pokemon.
</code></pre>

<p>Scenario: Find correct Pokemon from home page</p>

<pre><code>Given I am on the home page
When I type "Bulbasaur" in the search bar
And I click "Search"
Then I should be on the "search" page
And I should see "#001 - Bulbasaur"
And I should see an image with url "http://img.pokemondb.net/artwork/bulbasaur.jpg"
And I should see "Types: Grass, Poison"
</code></pre>

<p>Scenario: Show error text from home page</p>

<pre><code>Given I am on the home page
When I type "Johnny Bravo" in the search bar
And I click "Search"
Then I should be on the "search" page
And I should see "Lol! Could not find a Pokemon named 'Johnny Bravo.' Try something else!"
</code></pre>

<p>Scenario: Find correct Pokemon from search page</p>

<pre><code>Given I am on the search page
When I type "Bulbasaur" in the search bar
And I click "Search"
Then I should see "#001 - Bulbasaur"
And I should see an image with url "http://img.pokemondb.net/artwork/bulbasaur.jpg"
And I should see "Types: Grass, Poison"
</code></pre>

<p>Scenario: Show error text from search page</p>

<pre><code>Given I am on the search page
When I type "Johnny Bravo" in the search bar
And I click "Search"
Then I should be on the "search" page
And I should see "Lol! Could not find a Pokemon named 'Johnny Bravo.' Try something else!"
</code></pre>

<p>```</p>

<p>Now I&rsquo;ve overlooked a lot of tests that one would normally write while doing this, such as verifying that the search bar and search buttons exist and are enabled, but I&rsquo;d like to keep it simple for now and just stick to testing my search feature. What do these tests do? The first scenario starts on the home page, enters data in the search box, presses the search button, and then verifies that all expected Pokemon data is visible. When writing cukes, I can append statements with an &ldquo;And&rdquo; statement as seen above. Run Cucumber:</p>

<p><code>sh project/tools/test
$ cucumber
</code></p>

<p>Cucumber doesn&rsquo;t exactly give us errors, but it also doesn&rsquo;t give us success. Fortunately, what it did give us was sample code for all of the steps we need to write. So, let&rsquo;s perform some copy/paste magic and create a steps file:</p>

<p><code>sh project/tools/test
$ mkdir -p features/step_definitions
$ touch features/step_definitions/search_steps.rb
</code></p>

<p>``` ruby project/tools/test/features/step_definitions/search_steps.rb
Given /^I am on the home page$/ do
  pending # express the regexp above with the code you wish you had
end</p>

<p>When /^I type &ldquo;(.*?)&rdquo; in the search bar$/ do |arg1|
  pending # express the regexp above with the code you wish you had
end</p>

<p>When /^I click &ldquo;(.*?)&rdquo;$/ do |arg1|
  pending # express the regexp above with the code you wish you had
end</p>

<p>Then /^I should be on the &ldquo;(.*?)&rdquo; page$/ do |arg1|
  pending # express the regexp above with the code you wish you had
end</p>

<p>Then /^I should see &ldquo;(.*?)&rdquo;$/ do |arg1|
  pending # express the regexp above with the code you wish you had
end</p>

<p>Then /^I should see an image with url &ldquo;(.*?)&rdquo;$/ do |arg1|
  pending # express the regexp above with the code you wish you had
end</p>

<p>Given /^I am on the search page$/ do
  pending # express the regexp above with the code you wish you had
end
```</p>

<p>If I futilely run &ldquo;cucumber&rdquo; again now, my tests still don&rsquo;t pass because I haven&rsquo;t actually implemented my steps. This is where Capybara comes in. I found that a <a href="https://gist.github.com/428105">Capybara cheat sheet</a> is quite helpful while writing out my steps. The syntax I&rsquo;m going to use is similar to RSpec, except that it includes some Capybara methods. The first two test steps I want to deal with are the &ldquo;Given&rdquo; steps.</p>

<p>``` ruby project/tools/test/features/step_definitions/search_steps.rb
Given /^I am on the home page$/ do
  visit &lsquo;/&rsquo;
end</p>

<p>Given /^I am on the search page$/ do
  visit &lsquo;/&rsquo;
  click_button &ldquo;Search&rdquo;
end
```</p>

<p>All these statements are just Regular Expressions, as indicated by the /^$/. The regex acts as a sort of method name that Cucumber finds to run the steps. Given I am on the home page is trivial: just &lsquo;visit&rsquo; the index. Given I am on the search page will first require me to click the &ldquo;search&rdquo; button. This is valid because my spec above says this is how to get to the search page. Now can do the &lsquo;When&rsquo; statements.</p>

<p>``` ruby project/tools/test/features/step_definitions/search_steps.rb
When /^I type &ldquo;(.*?)&rdquo; in the search bar$/ do |arg1|
  fill_in &ldquo;pokemon-input&rdquo;, :with => arg1
end</p>

<p>When /^I click &ldquo;(.*?)&rdquo;$/ do |arg1|
  click_button arg1
end
```</p>

<p>When I click just needs to click a button/link/whatever on the screen. The &ldquo;(.*?)&rdquo; is a regular expression that will match anything in quotes and assign it to the variable &lsquo;arg1.&rsquo; So I can give any button description and Capybara will try to click a button with the given content. When I type in the search bar takes the regex arg1 and uses the &ldquo;fill_in&rdquo; method to fill in a text input with id &ldquo;pokemon-input.&rdquo; The rest of the steps are all about what should be observed after performing the Given/When steps.</p>

<p>``` ruby project/tools/test/features/step_definitions/search_steps.rb
Then /^I should be on the &ldquo;(.*?)&rdquo; page$/ do |arg1|
  current_path.should == &ldquo;/#{arg1}&rdquo;
end</p>

<p>Then /^I should see &ldquo;(.*?)&rdquo;$/ do |arg1|
  page.should have_content(arg1)
end</p>

<p>Then /^I should see an image with url &ldquo;(.*?)&rdquo;$/ do |arg1|
  find(:xpath, &ldquo;//img[@src=&lsquo;#{arg1}&rsquo;]&rdquo;).should_not be_nil
end
```</p>

<p>Now I have all of the necessary steps defined! So, I&rsquo;ll run Cucumber and&hellip; Actual errors! None of my four tests made it past the Given step, so I see the output &lsquo;(4 failed, 19 skipped).&rsquo; The only way to fix these errors is to finally start writing a web application. So I&rsquo;ll move back out to the root of my project directory and create a file for my application called &lsquo;app.rb&rsquo; and give it the most basic information to run. And, if you haven&rsquo;t already, install Sinatra.</p>

<p><code>bash
$ sudo gem install sinatra
</code></p>

<p>``` ruby project/app.rb
require &lsquo;sinatra&rsquo;
require &lsquo;haml&rsquo;</p>

<p>class Application &lt; Sinatra::Base</p>

<pre><code>get '/' do
    haml :index
end
</code></pre>

<p>end
```</p>

<p>The Application class inherits from the Sinatra::Base class. This allows me to define a &lsquo;get&rsquo; operation to perform actions and load a web page. &lsquo;get \&rsquo;\&lsquo; do&rsquo; signifies the first page a user sees when they go to my web application, commonly known as a home or index page. I plan to use <a href="http://haml.info">HAML</a> to create my page, so I make a call to haml followed by the name of my HAML document as a symbol. We need to define an &lsquo;index.haml&rsquo; page and stick it in a directory called &lsquo;views&rsquo; for Sinatra to find it.</p>

<p><code>bash
$ sudo gem install haml
</code></p>

<p>``` haml project/views/index.haml
!!!
%html</p>

<pre><code>%head
    %title Pokemon App
%body
    LOL HAI.
</code></pre>

<p>```</p>

<p>Tough work. If you&rsquo;re not familiar with HAML, it&rsquo;s a markup language that is &ldquo;compiled&rdquo; into an HTML page. The main difference between HAML and HTML is that HAML parses white space to figure out where closing tags should be placed. So now I want to run my application. I want to run it using &lsquo;rackup,&rsquo; so I&rsquo;d like to define a &lsquo;config.ru&rsquo; file in the root of my project directory to do all the work for me.</p>

<p>``` ruby project/config.ru
require &lsquo;./app&rsquo;</p>

<p>run Application.new
```</p>

<p>Now we run &lsquo;rackup&rsquo; from the root of my project directory and see the fruits of my labor. Open up a web browser and enter &lsquo;localhost:9292&rsquo; in the address bar. You should see a very simple web page with the content of &ldquo;LOL HAI&rdquo; and a title of &ldquo;Pokemon App.&rdquo; If you view the source, you&rsquo;ll see the HTML the HAML was compiled into. Just beautiful, isn&rsquo;t it? Now if I switch back to my test directory and run Cucumber, what happens? The same result. That&rsquo;s because I need to tell Capybara what to load before trying to run the tests. I do this by defining an &ldquo;env.rb&rdquo; file in a &ldquo;support&rdquo; directory of the features directory.</p>

<p>``` ruby project/tools/test/features/support/env.rb
require &lsquo;capybara&rsquo;
require &lsquo;capybara/cucumber&rsquo;</p>

<p>require_relative &ldquo;../../../../app&rdquo;</p>

<p>Capybara.app = Application
```</p>

<p>All I do is require my &ldquo;app.rb&rdquo; file which is seemingly <em>forever</em> away and then set the Capybara.app variable to my Application class. Now I run Cucumber and&hellip; &lsquo;(4 failed, 17 skipped, 2 passed)&rsquo; Two steps passed! Yippee! Now if only the rest passed as well. Looking at my &lsquo;search.feature&rsquo; file, I can see that the first &lsquo;When&rsquo; step is about typing into the search bar. So my first design decision is what kind of search bar I want. I&rsquo;ve opted for the fun way out: using the <a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap&rsquo;s</a> <a href="http://twitter.github.com/bootstrap/javascript.html#typeahead">typeahead</a>. The typeahead has functionality to give suggestions while the user types, and the best news is this is already coded for us. Adding the code for my search bar and a search button:</p>

<p>``` haml project/views/index.haml
!!!
%html</p>

<pre><code>%head
    %title Pokemon App
    %link(rel="stylesheet" href="http://twitter.github.com/bootstrap/assets/css/bootstrap.css")
%body
    %script{:type =&gt; "text/javascript", :src  =&gt; "http://code.jquery.com/jquery.min.js"}
    %script{:type =&gt; "text/javascript", :src  =&gt; "http://twitter.github.com/bootstrap/assets/js/bootstrap-typeahead.js"}
    #search{:style =&gt; "position: absolute; width: 100%; text-align: center; top: 10%;"}
        %form{:action =&gt; "search", :method =&gt; "POST", :id =&gt; "pokemon-search"}
            %input{:type =&gt; "text", :class =&gt; "input-large", :id =&gt; "pokemon-input", :name =&gt; "pokemon", "data-provide"=&gt;"typeahead", "data-items"=&gt;"10", "autocomplete"=&gt;"off", :autofocus =&gt; "", :placeholder =&gt; "Find a Pokémon...", "data-source" =&gt; Pokemon.only(:name).map {|x| x.name}}
            %button{:type=&gt;"submit", :class =&gt; "btn btn-small", :style =&gt; "margin-bottom: 10px; font-weight: bold;"}
                Search
</code></pre>

<p>```</p>

<p>In the &lt;head> tag, I include a link to the Bootstrap stylesheet. In the &lt;body> tag, I include a link to the JQuery and Bootstrap Typeahead JavaScript files remotely so I don&rsquo;t have to keep track of them. I then add a &lt;div> tag called &ldquo;search&rdquo; and center it on the page. Inside the div tag I create a form whose action sends a POST signal to the &ldquo;search&rdquo; action. Inside the form is first the typeahead, then a small submit button. The important parameters in the typeahead are &ldquo;data-items&rdquo; and &ldquo;data-source;&rdquo; &ldquo;data-items&rdquo; tells the JavaScript function how many items to suggest at a time, and &ldquo;data-source&rdquo; is an array of data for the JavaScript to search. Notice that my &ldquo;data-source&rdquo; uses the Pokemon class <a href="/blog/2013/01/05/schemaless-databases-with-ruby-and-mongodb/">created previously</a>, so I need to be able to set up a <a href="/blog/2013/01/05/moving-from-the-mongodb-ruby-driver-to-mongoid/">Mongoid connection</a> to access that data. I&rsquo;ll make this connection in my &ldquo;config.ru&rdquo; file:</p>

<p>``` ruby project/config.ru
require &lsquo;./app&rsquo;
require &lsquo;mongoid&rsquo;</p>

<p>class Application</p>

<pre><code>configure do
    Mongoid.load! 'mongoid.yml'
end
</code></pre>

<p>end</p>

<p>run Application.new
```</p>

<p>I have chosen to extend the Application class in my &ldquo;config.ru&rdquo; file to prevent interference with my test setups later. Taking a look at the application would be a good idea, but if I run &ldquo;rackup&rdquo; now Mongoid will complain about environment setup. By default, &ldquo;Mongoid.load!&rdquo; will try to load the &ldquo;development&rdquo; settings, so I need to include a &ldquo;development&rdquo; setup in my &ldquo;mongoid.yml.&rdquo; For now, it&rsquo;s going to be identical to my &ldquo;test&rdquo; environment setup except for the database name:</p>

<p>``` yml project/mongoid.yml
test:
  sessions:</p>

<pre><code>default:
  database: test
  hosts:
    - localhost
</code></pre>

<p>development:
  sessions:</p>

<pre><code>default:
  database: dev
  hosts:
    - localhost
</code></pre>

<p>```</p>

<p>And ensuring some Pokemon are in the &ldquo;dev&rdquo; database:</p>

<p>``` bash Populating the dev database
$ irb</p>

<blockquote><blockquote><p>Dir.pwd
=> &ldquo;project/tools/populate&rdquo;
require &lsquo;mongoid&rsquo;
=> true
Mongoid.load! &lsquo;../../mongoid.yml&rsquo;
=> {&ldquo;sessions&rdquo;=>{&ldquo;default&rdquo;=>{&ldquo;database&rdquo;=>&ldquo;dev&rdquo;, &ldquo;hosts&rdquo;=>[&ldquo;localhost&rdquo;]}}}
require &lsquo;./populater&rsquo;
=> true
Populater.new.add_pokemon 152
=> nil</p>

<p>```</p></blockquote></blockquote>

<p>And requiring the Pokemon model in app.rb:</p>

<p>``` ruby project/app.rb
require &lsquo;sinatra&rsquo;
require &lsquo;haml&rsquo;</p>

<p>require_relative &lsquo;pokemon&rsquo;</p>

<p>class Application &lt; Sinatra::Base</p>

<pre><code>get '/' do
    haml :index
end
</code></pre>

<p>end
```</p>

<p>Finally, run &lsquo;rackup&rsquo; from the root of the &lsquo;project&rsquo; directory and load up the web application at &lsquo;localhost:9292.&rsquo; There&rsquo;s now a typeahead and a search button in the top center of the page, and typing in the &lsquo;Search&rsquo; bar shows up to 10 suggestion Pokemon. Now I&rsquo;ll return to my Cucumber tests. I need to add a line in the &lsquo;env.rb&rsquo; file to set up the Mongoid environment and ensure there are Pokemon in the collection.</p>

<p>``` ruby project/tools/test/features/support/env.rb
require &lsquo;capybara&rsquo;
require &lsquo;capybara/cucumber&rsquo;
require &lsquo;mongoid&rsquo;</p>

<p>require_relative &lsquo;../../../populate/populater&rsquo;
require_relative &ldquo;../../../../app&rdquo;</p>

<p>Mongoid.load! &lsquo;../../mongoid.yml&rsquo;, :test</p>

<p>Populater.new.add_pokemon(10)</p>

<p>Capybara.app = Application
```</p>

<p>Now I can run Cucumber and see some jovial results: &lsquo;(4 failed, 9 skipped, 10 passed).&rsquo; I now have more steps passing than failing! The root cause of the failures is that there currently is no &ldquo;search&rdquo; page; let&rsquo;s fix that:</p>

<p>``` ruby project/app.rb
&hellip;
class Application &lt; Sinatra::Base</p>

<pre><code>...
post '/search' do
    haml :search
end
</code></pre>

<p>end
```</p>

<p>I want my search page to have a search bar just like my index page. If I want them to be identical, I want to only have to change that code once. When writing HAML, I can create a &lsquo;layout.haml&rsquo; file to act as a base page for my application and move all the text from &lsquo;index.haml.&rsquo; I&rsquo;ll add a &lsquo;=yield&rsquo; statement where I want the information from &lsquo;index.haml&rsquo; and &lsquo;search.haml&rsquo; to be placed.</p>

<p>``` haml project/views/layout.haml
!!!
%html</p>

<pre><code>%head
    %title Pokemon App
    %link(rel="stylesheet" href="http://twitter.github.com/bootstrap/assets/css/bootstrap.css")
%body
    %script{:type =&gt; "text/javascript", :src  =&gt; "http://code.jquery.com/jquery.min.js"}
    %script{:type =&gt; "text/javascript", :src  =&gt; "http://twitter.github.com/bootstrap/assets/js/bootstrap-typeahead.js"}
    #search{:style =&gt; "position: absolute; width: 100%; text-align: center; top: 10%;"}
        %form{:action =&gt; "search", :method =&gt; "POST", :id =&gt; "pokemon-search"}
            %input{:type =&gt; "text", :class =&gt; "input-large", :id =&gt; "pokemon-input", :name =&gt; "pokemon", "data-provide"=&gt;"typeahead", "data-items"=&gt;"10", "autocomplete"=&gt;"off", :autofocus =&gt; "", :placeholder =&gt; "Find a Pokémon...", "data-source" =&gt; Pokemon.only(:name).map {|x| x.name}}
            %button{:type=&gt;"submit", :class =&gt; "btn btn-small", :style =&gt; "margin-bottom: 10px; font-weight: bold;"}
                Search
    =yield
</code></pre>

<p>```</p>

<p>``` haml project/views/index.haml</p>

<h1>search-text{:style => &ldquo;position: absolute; width: 100%; text-align: center; top: 2%; font-weight: bold;&rdquo;}</h1>

<pre><code>Begin typing to search for your Pokemon!
</code></pre>

<p>```</p>

<p>At this point, I&rsquo;ll create a &lsquo;search.haml&rsquo; file in the &lsquo;views&rsquo; directory, but leave it empty. Running Cucumber now, I get &lsquo;(4 failed, 4 skipped, 15 passed).&rsquo; Pretty close! All I fail now is actually seeing the desired information on the page. First I want to get access to the Pokemon searched for: I can do that by parsing the params passed to us in app.rb:</p>

<p>``` ruby project/app.rb
&hellip;</p>

<p>class Application &lt; Sinatra::Base</p>

<pre><code>...
post '/search' do
    @pokemon = Pokemon.where(name: params[:pokemon]).first
    haml :search
end
</code></pre>

<p>end
```</p>

<p>So now on my search page:</p>

<p>``` haml project/views/search.haml</p>

<h1>search-text{:style => &ldquo;position: absolute; width: 100%; text-align: center; top: 2%; font-weight: bold;&rdquo;}</h1>

<pre><code>Search for another Pokemon.
</code></pre>

<h1>search-results{:style => &ldquo;position: absolute; width: 100%; text-align: center; top: 20%; font-weight: bold;&rdquo;}</h1>

<pre><code>%img{:src =&gt; @pokemon.image, :height =&gt; "250px"}
%br
= "##{@pokemon.number} - #{@pokemon.name}"
%br
= "Types: #{@pokemon.types.first}#{@pokemon.types.count &lt; 2 ? ' ' : ', ' + @pokemon.types.last}"
</code></pre>

<p>```</p>

<p>I reference the class variable &ldquo;@pokemon&rdquo; and access its data. To output Ruby-formatted strings, I use an &ldquo;=&rdquo; sign. Running Cucumber, I now see &lsquo;(2 failed, 21 passed).&rsquo; 2 of my 4 tests are passing! A trivial amount of investigation reveals that I didn&rsquo;t deal with the situation where the user types in garbage data. That can mostly be done in the HAML file, but I also want a way to get the bad text the user gave me so they can see what was wrong.</p>

<p>``` haml project/views/search.haml</p>

<h1>search-text{:style => &ldquo;position: absolute; width: 100%; text-align: center; top: 2%; font-weight: bold;&rdquo;}</h1>

<pre><code>Search for another Pokemon.
</code></pre>

<h1>search-results{:style => &ldquo;position: absolute; width: 100%; text-align: center; top: 20%; font-weight: bold;&rdquo;}</h1>

<pre><code>- unless @pokemon.nil?
    %img{:src =&gt; @pokemon.image, :height =&gt; "250px"}
    %br
    = "##{@pokemon.number} - #{@pokemon.name}"
    %br
    = "Types: #{@pokemon.types.first}#{@pokemon.types.count &lt; 2 ? ' ' : ', ' + @pokemon.types.last}"
- else
    = "Lol! Could not find a Pokemon named '#{@name}.' Try something else!"
</code></pre>

<p>```</p>

<p>``` ruby project/app.rb
&hellip;
class Application &lt; Sinatra::Base</p>

<pre><code>...
post '/search' do
    @name = params[:pokemon]
    @pokemon = Pokemon.where(name: @name).first
    haml :search
end
</code></pre>

<p>end
```</p>

<p>Ruby code with no output is preceded with a &lsquo;&ndash;&rsquo; and because HAML is space-sensitive, there&rsquo;s no need to include &lsquo;end&rsquo; statements. Now I run Cucumber and&hellip; 4 scenarios/23 steps passed! I have a functional web application! Of course, the page itself is somewhat bland, some of the styles could be put in a stylesheet and reused, and the only tests I&rsquo;ve written are for super-high-level functionality. Those are all problems someone with infinite time would deal with, so I&rsquo;ll just leave the page is is for now.</p>

<p>The next blog post <a href="/blog/categories/pokephile">in this series</a> will be about deploying this application to the web using Heroku.</p>
]]></content>
  </entry>
  
</feed>
