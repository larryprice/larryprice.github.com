<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Larry Price]]></title>
  <link href="https://larry-price.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="https://larry-price.com/"/>
  <updated>2020-11-03T11:30:15-06:00</updated>
  <id>https://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    <email><![CDATA[larry@larry-price.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Started with React Hooks]]></title>
    <link href="https://larry-price.com/blog/2019/02/09/getting-started-with-react-hooks/"/>
    <updated>2019-02-09T13:10:46-06:00</updated>
    <id>https://larry-price.com/blog/2019/02/09/getting-started-with-react-hooks</id>
    <content type="html"><![CDATA[<p><a href="https://reactjs.org/docs/hooks-intro.html">React Hooks</a> are a new feature allowing developers to use state in functional components officially released in <a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html">React 16.8</a>. I am in love with the idea of Hooks, so much so that I&rsquo;m giving an introductory talk on the topic at an <a href="https://www.meetup.com/C-U-JavaScript/events/258294308/">upcoming local JavaScript meetup</a>.</p>

<p>All code from this post can be found in a <a href="https://codepen.io/collection/XMoJzy/">codepen collection</a>.</p>

<h3>Functional Components</h3>

<p>A functional component (also sometimes referred to as a &ldquo;stateless&rdquo; component) is a method of defining React components with only a render method. These components still take in readonly props and return some JSX, but until now have had no means to perform any stateful logic. The following is a simple functional component that creates a button for canceling a user&rsquo;s account:</p>

<pre><code class="javascript https://codepen.io/larryprice/pen/BMJYwe">const CancelAccountDeletion = ({onClick}) =&gt; (
  &lt;button className="btn btn-default btn-lg cancel-account-deletion" onClick={onClick}&gt;
    &lt;span className="glyphicon glyphicon glyphicon-ban-circle"&gt;&lt;/span&gt;
    Cancel Account
  &lt;/button&gt;
);
</code></pre>

<p>The component takes in a single prop <code>onClick</code> that is called when the button is clicked.</p>

<h3>Adding Stateful Logic The Old Way</h3>

<p>Let&rsquo;s say that we want to add some stateful logic to that component. Marketing has started complaining that users clicking our current &ldquo;Cancel Account&rdquo; button contribute to a loss of revenue, and we need to slow that loss down to appease investors this quarter. We get design involved and decide to prompt the user several times to confirm their cancellation. We&rsquo;ll need to keep track of the number of clicks and the current prompt in state.</p>

<p>Here&rsquo;s how we might do that on February 5th, 2019, using class components:</p>

<pre><code class="javascript https://codepen.io/larryprice/pen/XOgKYd">const messages = ['Really?', 'Don\'t leave me!', 'OK, fine!'];
class CancelAccountDeletion extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      buttonText: 'Cancel',
      clicks: 0,
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.clicks !== this.state.clicks) {
      if (this.state.clicks &lt; messages.length) {
        return this.setState((prevState) =&gt; ({
          buttonText: messages[prevState.clicks],
        }));
      }

      return this.props.onClick();
    }
  }

  render() {
    return (
      &lt;button className="btn btn-default btn-lg cancel-account-deletion"
          onClick={() =&gt; this.setState((prevState) =&gt; ({
            clicks: prevState.clicks + 1,
          }))}&gt;
        &lt;span className="glyphicon glyphicon glyphicon-ban-circle"&gt;&lt;/span&gt;
        {this.state.buttonText}
      &lt;/button&gt;
    );
  }
}
</code></pre>

<p>Wow! We&rsquo;ve nearly tripled the size of our original component here. In this stateful world, we needed to extend the <code>React.Component</code> class, define a constructor to set our initial state, update our state when the button is clicked, and add the <code>componentDidUpdate</code> lifecycle method. The <code>componentDidUpdate</code> method is called on every re-render, so we first check to see if the number of <code>clicks</code> changed before taking any action. If it did, we check to see if we have more messages than clicks and update the prompt text; otherwise, we call the original <code>onClick</code> function from our props and, unfortunately for our sales goals, churn another user.</p>

<p>This is a lot of boilerplate and has a tendency to get complex really fast. If only there was another way!</p>

<p>&ldquo;Well, actually, Papa Larry,&rdquo; I hear you interjecting from behind your monitor, &ldquo;we could do this without a lifecycle method and only one piece of state.&rdquo; My dear friend. Yes, this code is slightly contrived so that I can show you all the main features of hooks with a fairly straightforward example. Just keep your susurruses to yourself until after the show.</p>

<h3>Adding Stateful Logic the New Way</h3>

<p>This is where Hooks come into play. Let&rsquo;s fast-forward from early evening in the American Midwest on February 5th, 2019, to late evening, when suddenly React 16.8 was released and it was officially titled &ldquo;The One With Hooks.&rdquo;</p>

<p>Let&rsquo;s take our original functional component and add state with Hooks:</p>

<pre><code class="javascript https://codepen.io/larryprice/pen/vbgwGx">const messages = ['Cancel', 'Really?', 'Don\'t leave me!', 'OK, fine!'];
const CancelAccountDeletion = ({onClick}) =&gt; {
  const [clicks, setClicks] = useState(0);
  const [buttonText, setButtonText] = useState();

  useEffect(() =&gt; {
    if (clicks &lt; messages.length) {
      return setButtonText(messages[clicks]);
    }
    return onClick();
  }, [clicks]);

  return (
    &lt;button onClick={() =&gt; setClicks(clicks+1)}
        className="btn btn-default btn-lg cancel-account-deletion"&gt;
      &lt;span className="glyphicon glyphicon glyphicon-ban-circle"&gt;&lt;/span&gt;
      {buttonText}
    &lt;/button&gt;
  );
};
</code></pre>

<p>Our Hooks implementation is about half as long as our class implementation. I would argue that it&rsquo;s also significantly easier to read. Let&rsquo;s break this down bit-by-bit to discuss each piece of the hooks API:</p>

<pre><code class="javascript">const [clicks, setClicks] = useState(0);
const [buttonText, setButtonText] = useState();
</code></pre>

<p>At the top of our function, we call the <code>useState</code> method to declare two state variables: <code>clicks</code> and <code>buttonText</code>. <code>useState</code> takes in an initial value and returns a state variable and setter method, which we access locally using array destructuring. In this case, we set the initial state of <code>clicks</code> to <code>0</code> and leave <code>buttonText</code> empty.</p>

<p>Behind-the-scenes, React is using our component&rsquo;s scope to create and track these state variables. We <em>must</em> always define these variables in the same order when this function is executed, or we&rsquo;ll get our variables all mixed up and our logic won&rsquo;t make any sense.</p>

<pre><code class="javascript">useEffect(() =&gt; {
  if (clicks &lt; messages.length) {
    return setButtonText(messages[clicks]);
  }
  return onClick();
}, [clicks]);
</code></pre>

<p>The <code>useEffect</code> method is essentially a replacement for the <code>componentDidMount</code> and <code>componentDidUpdate</code> lifecycle methods. It takes in a function that will be called after every render. Here we take advantage of closures to test the value of our <code>clicks</code> state variable and use <code>setButtonText</code> to update our <code>buttonText</code> state variable. The second argument to <code>useEffect</code> is an array of state variables to check - if none of the given state variables were changed, the effect will be skipped.</p>

<p>We can call <code>useEffect</code> as many times as we want in our component. This allows us to create a clear separation of concerns if we need to define several different effects.</p>

<pre><code class="javascript">return (
  &lt;button onClick={() =&gt; setClicks(clicks+1)}
      className="btn btn-default btn-lg cancel-account-deletion"&gt;
    &lt;span className="glyphicon glyphicon glyphicon-ban-circle"&gt;&lt;/span&gt;
    {buttonText}
  &lt;/button&gt;
);
</code></pre>

<p>This is our same old render logic, but in this case we&rsquo;re using the <code>setClicks</code> function returned to us by <code>useState</code>.</p>

<h3>Custom Hooks</h3>

<p>Design and marketing like this concept of delaying an action and just changing the text so much that they want to use it all over the site. Now we have stateful logic that needs to be reused. This is where the concept of &ldquo;Custom Hooks&rdquo; comes in:</p>

<pre><code class="javascript https://codepen.io/larryprice/pen/GzENrZ">const useTextByCount = (count, messages, onFinished) =&gt; {
  const [text, setText] = useState(messages[0]);

  useEffect(() =&gt; {
    if (count &lt; messages.length) {
      return setText(messages[count]);
    }
    return onFinished();
  }, [count]);

  return text;
};

const messages = ['Cancel', 'Really?', 'Don\'t leave me!', 'OK, fine!']
const CancelAccountDeletion = ({onClick}) =&gt; {
  const [clicks, setClicks] = useState(0);
  const buttonText = useTextByCount(clicks, messages, onClick);

  return (
    &lt;button onClick={() =&gt; setClicks(clicks+1)}
        className="btn btn-default btn-lg cancel-account-deletion"&gt;
      &lt;span className="glyphicon glyphicon glyphicon-ban-circle"&gt;&lt;/span&gt;
      {buttonText}
    &lt;/button&gt;
  )
};
</code></pre>

<p>Here I&rsquo;ve created my own hook called <code>useTextByCount</code> that abstracts away the entire concept of the <code>buttonText</code> state variable. We can use this custom hook in any functional component. Abstracting stateful logic is a tall task in class components, but it&rsquo;s completely natural using Hooks.</p>

<h3>Conclusion</h3>

<p>Hooks are the result of the React maintainers responding to the way React developers want to write code, enabling us to use powerful stateful concepts in a cleaner, functional system. This is a natural next step for the React API, but it&rsquo;s not going to deprecate all your class components. Hooks are completely optional and backwards compatible with current React concepts, so there&rsquo;s no need to make a Jira ticket to refactor all your components tomorrow morning. Hooks are here to help you write new components faster and better, giving you new options when you need to start adding state to that simple button component.</p>

<p>Check out the <a href="https://reactjs.org/docs/hooks-intro.html">Hooks Guide</a> and the <a href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks</a> for more information.</p>

<p>Happy hooking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use getDerivedStateFromProps in React 16.3+]]></title>
    <link href="https://larry-price.com/blog/2018/06/27/how-to-use-getderivedstatefromprops-in-react-16-dot-3-plus/"/>
    <updated>2018-06-27T15:12:09-05:00</updated>
    <id>https://larry-price.com/blog/2018/06/27/how-to-use-getderivedstatefromprops-in-react-16-dot-3-plus</id>
    <content type="html"><![CDATA[<p>From <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">a blog post in late March 2018</a>, it was announced that the React lifecycle methods <code>componentWillReceiveProps</code>, <code>componentWillMount</code>, and <code>componentWillUpdate</code> will be deprecated in a future version of React. This is because of the eventual migration of React to async rendering; these lifecycle methods will become unreliable when async rendering is made default.</p>

<p>In place of these methods, the new <strong>static</strong> method <code>getDerivedStateFromProps</code> was introduced. My team and I struggled at first in wrapping our heads around how to migrate our many uses of <code>componentWillReceiveProps</code> to this new method. It&rsquo;s generally easier than you think, but you need to keep in mind that the new method is <strong>static</strong>, and therefore does not have access to the <code>this</code> context that the old lifecycle methods provided.</p>

<p><code>getDerivedStateFromProps</code> is invoked every time a component is rendered. It takes in two arguments: the next <code>props</code> object (which may be the same as the previous object) and the previous <code>state</code> object of the component in question. When implementing this method, we need to return the changes to our component <code>state</code> or <code>null</code> (or <code>{}</code>) if no changes need to be made.</p>

<h3>componentWillReceiveProps</h3>

<p>Here&rsquo;s a pattern we were using in many components throughout our codebase:</p>

<pre><code class="javascript">componentWillReceiveProps(nextProps) {
  if (nextProps.selectedTab !== this.state.selectedTab) {
    this.setState(() =&gt; { return {selectedTab: nextProps.selectedTab} })
  }
}
</code></pre>

<p>This lifecycle method fired when we were about to receive new <code>props</code> in our component, passing in the new value as the first argument. We needed to check whether the new <code>props</code> indicated a change in the state of our tab bar, which we stored in <code>state</code>. This is one of the simplest patterns to address with <code>getDerivedStateFromProps</code>:</p>

<pre><code class="javascript">static getDerivedStateFromProps(nextProps, prevState) {
  return nextProps.selectedTab === prevState.selectedTab
    ? {}
    : {selectedTab: nextProps.selectedTab}
}
</code></pre>

<p>This code works in exactly the same way, but, since it&rsquo;s <strong>static</strong>, we no longer use the context provided by <code>this</code>. Instead, we return any state changes. In this case, I&rsquo;ve returned an empty object (<code>{}</code>) to indicate no state change when the tabs are identical; otherwise, I return an object with the new <code>selectedTab</code> value.</p>

<p>Sometimes you may have to perform some operations on the new <code>props</code>, but then you can still just compare the result to your previous state to figure out if anything changed. There may be other areas where you need to store some extra state duplicating your old <code>props</code> to make this work, but that may also be an indication that you need to use an alternative method.</p>

<h3>componentWillMount</h3>

<p>We also needed to replace calls to <code>componentWillMount</code>. I found that these calls were usually directly replaceable by <code>componentDidMount</code>, which will allow your component to perform an initial render and then execute blocking tasks. This may also require adding some loading-style capacity to your component, but will be better than a hanging app.</p>

<p>Here&rsquo;s an example of a <code>componentWillMount</code> we had originally that blocked render until after an API call was made:</p>

<pre><code class="javascript">componentWillMount() {
  this.setState(() =&gt; {
    return {
      loading: 'Loading tool info'
    }
  })
  return getTool(this.props.match.params.id).then((res) =&gt; {
    this.setState(() =&gt; {
      return {
        tool: res,
        loading: null
      }
    })
  }).catch((err) =&gt; {
    api.errors.put(err)
    this.setState(() =&gt; {
      return {
        loading: null
      }
    })
  })
}
</code></pre>

<p>Afterwards, I changed the state to show the component as loading on initial render and replaced the <code>componentWillMount</code> with <code>componentDidMount</code>:</p>

<pre><code class="javascript">state = {
  tool: null,
  loading: 'Loading tool info'
}

componentDidMount() {
  return getTool(this.props.match.params.id).then((res) =&gt; {
    this.setState(() =&gt; { return {tool: res, loading: null} })
  }).catch((err) =&gt; {
    api.errors.put(err)
    this.setState(() =&gt; { return {loading: null} })
  })
}
</code></pre>

<h3>componentWillUpdate</h3>

<p>Very similar to the methods discussed above, <code>componentWillUpdate</code> is invoked when a component is about to receive new props and the <code>render</code> method is definitely going to be called. Here&rsquo;s an example of something we were doing previously:</p>

<pre><code class="javascript">componentWillUpdate(nextProps) {
  if (!nextProps.user.isLogged &amp;&amp; !nextProps.user.authenticating) {
    this.context.router.history.push('/')
  }
}
</code></pre>

<p>And, replacing that usage with <code>componentDidUpdate</code>:</p>

<pre><code class="javascript">componentDidUpdate(/*prevProps, prevState*/) {
  if (!this.props.user.isLogged &amp;&amp; !this.props.user.authenticating) {
    this.context.router.history.push('/')
  }
}
</code></pre>

<p><code>componentDidUpdate</code> is similar to <code>componentDidMount</code> except that is caused after a change in state or props occurs instead of just on initial mount. As opposed to <code>getDerivedStateFromProps</code>, we have access to the context provided by <code>this</code>. Note that this method also has arguments for <code>prevProps</code> and <code>prevState</code>, which provides the previous versions of the component&rsquo;s <code>props</code> and <code>state</code> for comparison to the current values.</p>

<h3>Conclusion</h3>

<p>The deprecation of these lifecycle methods won&rsquo;t happen until React 17, but it&rsquo;s always good to plan ahead. Many of the ways my team was using these deprecated methods could be considered an anti-pattern, and I suspect that your team may be in the same predicament.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async and Await - A New Promise]]></title>
    <link href="https://larry-price.com/blog/2018/02/02/async-and-await-a-new-promise/"/>
    <updated>2018-02-02T15:19:48-06:00</updated>
    <id>https://larry-price.com/blog/2018/02/02/async-and-await-a-new-promise</id>
    <content type="html"><![CDATA[<p>In my <a href="/blog/2017/09/14/promise-youll-call-back/">last post</a>, I discussed the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ES2015 concept of a <code>Promise</code></a>. A <code>Promise</code> provides a simplified mechanism for performing asynchronous work in JavaScript without using the classic <code>setTimeout</code>-callback approach. Seeing as it&rsquo;s been about 4 months since my previous post, a new asynchronous concept is on the rise as part of the <a href="https://tc39.github.io/ecma262/2017/#sec-async-function-definitions">ES2017 specification</a>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code> and <code>await</code></a>.</p>

<p>I became aware of <code>async</code> and <code>await</code> after reading <a href="https://davidwalsh.name/async-await">David Walsh&rsquo;s blog</a>, at which point I disregarded the new features as being &ldquo;too soon&rdquo; and &ldquo;not different enough&rdquo; from a <code>Promise</code> to warrant a second thought. Then, yesterday, I used them, and my life was, once again, forever changed.</p>

<p><code>await</code> is used to essentially wait for a <code>Promise</code> to finish. Instead of using a callback with a <code>then</code> clause, <code>await</code> allows you to perform the action and/or store the result like you&rsquo;re within a synchronous function.</p>

<p><code>async</code> is a keyword identifier used on functions to specify that that function will use <code>await</code>. Try to call <code>await</code> in a function not labeled as <code>async</code> and you&rsquo;re going to have a bad time. Any <code>async</code> function returns a <code>Promise</code>.</p>

<p>Let&rsquo;s see an example:</p>

<pre><code class="javascript">function getFirstName() { return Promise.resolve('Charles'); }
function getMiddleName() { return Promise.resolve('Entertainment'); }
function getLastName() { return Promise.resolve('Cheese'); }

async function getName() {
  const first = await getFirstName();
  const middle = await getMiddleName();
  const last = await getLastName();

  return `${first} ${middle} ${last}`;
}

getName().then((name) =&gt; {
  console.log(name);
});

console.log('My next guest needs no introduction:');

// Result:
//   My next guest needs no introduction:
//   Charles Entertainment Cheese
</code></pre>

<p>We have three functions which each return a <code>Promise</code>, and an <code>async</code> function which calls those functions sequentially and uses the results to construct a string. We call the <code>getName</code> function (which is <code>async</code> and therefore returns a <code>Promise</code>) and log the results. Our last command logs a special message. Due to the asynchronous nature of the <code>getName</code> function, our special message is logged first, and then the result of <code>getName</code>.</p>

<p>This comes in handy when you&rsquo;re depending on the results of a <code>Promise</code> to do some work or pass into another asynchronous call. But, in the case of our <code>getName</code> function above, we could be getting all three of the names at once. This calls for the brilliant <code>Promise.all</code> method, which can also be used with <code>async</code>. Let&rsquo;s modify our sub-name functions to all use <code>async</code> and then fetch them all at once:</p>

<pre><code class="javascript">async function getFirstName() { return 'Charles'; }
async function getMiddleName() { return 'Entertainment'; }
async function getLastName() { return 'Cheese'; }

async function getName() {
  const names = await Promise.all([getFirstName(), getMiddleName(), getLastName()]);

  return `${names[0]} ${names[1]} ${names[2]}`;
}

getName().then((name) =&gt; {
  console.log(name);
});

console.log('My next guest needs no introduction:');

// Result:
//   My next guest needs no introduction:
//   Charles Entertainment Cheese
</code></pre>

<p>Since an <code>async</code> function just returns a <code>Promise</code>, we can directly use (and even inter-mix) <code>async</code> functions inside <code>Promise.all</code>, and the results come back in an ordered array.</p>

<p>OK, what if we want to fire off some long-running task and do some other work in the meantime? We can defer our use of <code>await</code> until after we&rsquo;ve performed all the intermediate work:</p>

<pre><code class="javascript">async function getFirstName() { return 'Charles'; }
async function getMiddleName() { return 'Entertainment'; }
async function getLastName() { return 'Cheese'; }

async function getName() {
  const first  = getFirstName();  // first, middle, and last will all
  const middle = getMiddleName(); // be pending Promises at this
  const last   = getLastName();   // point, to be resolved in time

  const title = Math.random() &gt; .5 ? 'Sr.' : 'Esq.';

  return `${await first} ${await middle} ${await last}, ${title}`;
}

getName().then((name) =&gt; {
  console.log(name);
});

console.log('My next guest needs no introduction:');

// Result will be quasi-random:
//   My next guest needs no introduction:
//   Charles Entertainment Cheese, (Esq.|Sr.)
</code></pre>

<p>This example reiterates that you can use <code>async</code> functions just like you would a <code>Promise</code>, but with the added benefit of using <code>await</code> to wait for the results when necessary.</p>

<p>I know what you&rsquo;re thinking: &ldquo;All these positives, Larry! Is there nothing negative about <code>async</code>/<code>await</code>?&rdquo; As always, there are a couple of pitfalls to using these functions. The biggest nuisance for me is the loss of the <code>catch</code> block when converting from a <code>Promise</code> chain. In order to catch errors with <code>async</code>/<code>await</code>, you&rsquo;ll have to go back to traditional <code>try/catch</code> statements:</p>

<pre><code class="javascript">async function checkStatus() { throw 'The Cheese is displeased!'; }

async function checks() {
  try {
    await checkStatus();
    return 'No problems.';
  } catch (e) {
    return e;
  }
}

checks().then((status) =&gt; {
  console.log(status)
})
console.log('Current status:');

// Result will be quasi-random:
//   Current status:
//   The Cheese is displeased!
</code></pre>

<p>The only other real downside is that <code>async</code> and <code>await</code> may not be fully supported in your users' browsers or your version of Node.JS. There are plenty of ways to get around this with Babel and polyfills, but, to be honest, I dedicated a large chunk of time yesterday afternoon to upgrading all of our libraries and babel versions to get this to work properly everywhere. Your mileage may vary, and, if you&rsquo;re reading this 6 months from when it was posted, I&rsquo;m sure it will be available by default in any implementations of ECMAScript.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise you'll call back: A guide to the Javascript Promise class]]></title>
    <link href="https://larry-price.com/blog/2017/09/14/promise-youll-call-back/"/>
    <updated>2017-09-14T21:45:08-05:00</updated>
    <id>https://larry-price.com/blog/2017/09/14/promise-youll-call-back</id>
    <content type="html"><![CDATA[<p><em>This article introduces the Javascript Promise class, and how to use a Promise to perform asynchronous work. At the end of this post, you&rsquo;ll have been exposed to the most important components of the Promise API.</em></p>

<p>Introduced in the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">ES2015 specification</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a> dryly describes a <code>Promise</code> as:</p>

<blockquote><p>The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.</p></blockquote>

<p>But&hellip; what exactly does that entail? How does it differ from just using callbacks?</p>

<p>Let&rsquo;s start with a simple example. If I want to perform an operation asynchronously, traditionally I would use <code>setTimeout</code> to do work after the main thread has finished and use a callback parameter to let the caller utilize the results. For example:</p>

<pre><code class="javascript">const someAsyncTask = (after) =&gt; {
  return setTimeout(() =&gt; {
    after('the task is happening');
  }, 0);
};

console.log('before calling someAsyncTask');

someAsyncTask((result) =&gt; {
  console.log(result);
});

console.log('after calling someAsyncTask');
</code></pre>

<p>Try running this yourself with <code>node</code>, and you&rsquo;ll see that &lsquo;before&hellip;&rsquo; and &lsquo;after&hellip;&rsquo; are printed followed by &lsquo;the task is happening&rsquo;.</p>

<p>This is perfectly valid code, but it&rsquo;s just so <em>unnatural</em> to handle asynchronous tasks this way. There&rsquo;s no standard to which parameter should be the callback, and there&rsquo;s no standard to what arguments will be passed back to a given callback. Let&rsquo;s take a look at the same situation using the new <code>Promise</code> class:</p>

<pre><code class="javascript">const someAsyncTask = () =&gt; {
  return Promise.resolve('the task is happening');
};

console.log('before calling someAsyncTask');

someAsyncTask().then((result) =&gt; {
  console.log(result);
});

console.log('after calling someAsyncTask');
</code></pre>

<p>Let&rsquo;s walk through this. In <code>someAsyncTask</code>, we&rsquo;re now returning a call to <code>Promise.resolve</code> with our result. We call <code>then</code> on the result of <code>someAsyncTask</code> and then handle the results. <code>Promise.resolve</code> is returning a resolved <code>Promise</code>, which is run asynchronously after the main thread finishes its initial work (the final <code>console.log</code>, in this case).</p>

<p>Immediately, this feels a lot cleaner to me, but this is a really simple example.</p>

<p>Think about a situation where you need to perform multiple asynchronous callbacks that each depend on the results of the last callback. Here&rsquo;s an example implementation using callbacks;</p>

<pre><code class="javascript">const getFirstName = (callback) =&gt; {
  return setTimeout(() =&gt; {
    callback('Harry');
  }, 0);
};

const getLastName = (callback) =&gt; {
  return setTimeout(() =&gt; {
    callback('Potter');
  }, 0);
};

const concatName = (first, last, callback) =&gt; {
  return setTimeout(() =&gt; {
    callback(`${first} ${last}`);
  }, 0);
}

getFirstName((first) =&gt; {
  getLastName((last) =&gt; {
    concatName(first, last, (fullname) =&gt; {
      console.log(fullname);
    });
  });
});
</code></pre>

<p>I think we can all agree that this is not friendly code. What makes a <code>Promise</code> truly special is its natural chainability. As long as we keep returning <code>Promise</code> objects, we can keep calling <code>then</code> on the results:</p>

<pre><code class="javascript">const getFirstName = (callback) =&gt; {
  return Promise.resolve('Harry');
};

const getLastName = (callback) =&gt; {
  return Promise.resolve('Potter');
};

const concatName = (first, last, callback) =&gt; {
  return Promise.resolve(`${first} ${last}`);
}

getFirstName().then((first) =&gt; {
  return getLastName().then((last) =&gt; {
    return concatName(first, last);
  });
}).then((fullname) =&gt; {
  console.log(fullname);
});
</code></pre>

<p>Since <code>concatName</code> is dependent on the result of both <code>getFirstName</code> and <code>getLastName</code>, we still do a little bit of nesting. However, our final asynchronous action can now occur on the outside of the nesting, which will take advantage of the last returned result of our <code>Promise</code> resolutions.</p>

<p>Error handling is another can of worms in callbacks. Which return value is the error and which is the result? Every level of nesting in a callback has to either handle errors, or maybe the top-most callback has to contain a try-catch block. Here&rsquo;s a particularly nasty example:</p>

<pre><code class="javascript">const getFirstName = (callback) =&gt; {
  return setTimeout(() =&gt; {
    if (Math.random() &gt; 0.5) return callback('Sorry, firstName errored');
    callback(null, 'Harry');
  }, 0);
};

const getLastName = (callback) =&gt; {
  return setTimeout(() =&gt; {
    if (Math.random() &gt; 0.5) return callback('Sorry, lastName errored');
    callback(null, 'Potter');
  }, 0);
};

const concatName = (first, last, callback) =&gt; {
  return setTimeout(() =&gt; {
    if (Math.random() &gt; 0.5) return callback('Sorry, fullName errored');
    callback(null, `${first} ${last}`);
  }, 0);
}

getFirstName((err, first) =&gt; {
  if (err) console.error(err); // no return, will fall through despite error
  getLastName((err, last) =&gt; {
    if (err) return console.error(err);
    concatName(first, last, (err, fullname) =&gt; {
      if (err) return console.error(err);
      console.log(fullname);
    });
  });
});
</code></pre>

<p>Every callback has to check for an individual error, and if any level mishandles the error (note the lack of a return on error after <code>getFirstName</code>), you&rsquo;re guaranteed to end up with undefined behavior. A <code>Promise</code> allows us to handle errors at any level with a <code>catch</code> statement:</p>

<pre><code class="javascript">const getFirstName = () =&gt; {
  if (Math.random() &gt; 0.5) return Promise.reject('Sorry, firstName errored');
  return Promise.resolve('Harry');
};

const getLastName = () =&gt; {
  if (Math.random() &gt; 0.5) return Promise.reject('Sorry, lastName errored');
  return Promise.resolve('Potter');
};

const concatName = (first, last) =&gt; {
  if (Math.random() &gt; 0.5) return Promise.reject('Sorry, fullName errored');
  return Promise.resolve(`${first} ${last}`);
}

getFirstName().then((first) =&gt; {
  return getLastName().then((last) =&gt; {
    return concatName(first, last);
  });
}).then((fullname) =&gt; {
  console.log(fullname);
}).catch((err) =&gt; {
  console.error(err);
});
</code></pre>

<p>We return the result of <code>Promise.reject</code> to signify that we have an error. We only need to call <code>catch</code> once. Any <code>then</code> statements from unresolved promises will be ignored. A <code>catch</code> could be inserted at any nesting point, which could give you the ability to continue the chain:</p>

<pre><code class="javascript">// ...

getFirstName().then((first) =&gt; {
  return getLastName().then((last) =&gt; {
    return concatName(first, last);
  }).catch((err) =&gt; {
    return concatName(first, 'Houdini');
  });
}).then((fullname) =&gt; {
  console.log(fullname);
}).catch((err) =&gt; {
  console.error(err);
});
</code></pre>

<p>So far, we&rsquo;ve been returning <code>Promise</code> objects using <code>resolve</code> and <code>reject</code>, but there&rsquo;s also the ability to define our own <code>Promise</code> objects with their own <code>resolve</code> and <code>reject</code> methods. Updating the <code>getFirstName</code> variable:</p>

<pre><code class="javascript">const getFirstName = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    if (Math.random() &gt; 0.5) return reject('Sorry, firstName errored');
    return resolve('Harry');
  });
}
// ...
</code></pre>

<p>We can also run our asynchronous tasks without nesting by using the <code>Promise.all</code> method:</p>

<pre><code class="javascript">// ...

Promise.all([getFirstName(), getLastName()]).then((names) =&gt; {
  return concatName(names[0], names[1]);
}).then((fullname) =&gt; {
  console.log(fullname);
}).catch((err) =&gt; {
  console.error(err);
});
</code></pre>

<p>Give <code>Promise.all</code> a list of promises and it will call them (in some order) and return all the results in an array (in the order given) as a resolved <code>Promise</code> once all given promises have been resolved. If any of the promises are rejected, the entire <code>Promise</code> will be rejected, resulting in the <code>catch</code> statement.</p>

<p>Sometimes you need to run several methods, and you only care about the first result. <code>Promise.race</code> is similar to <code>Promise.all</code>, but only waits for one of the given promises to return:</p>

<pre><code class="javascript">const func1 = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; resolve('func1'), 5*Math.random());
  });
}

const func2 = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; resolve('func2'), Math.random());
  });
}

Promise.race([func1(), func2()]).then((name) =&gt; {
  console.log(name);
}).catch((err) =&gt; {
  console.error(err);
});
</code></pre>

<p>Sometimes, &lsquo;func1&rsquo; will be printed, but most of the time &lsquo;func2&rsquo; will be printed.</p>

<p>&hellip;And that&rsquo;s the basics! Hopefully, you have a better understanding of how a <code>Promise</code> works and the advantages provided over traditional callback architectures. More and more libraries are depending on the <code>Promise</code> class, and you can really clean up your logic by using those methods. As Javascript continues to evolve, hopefully we find ourselves getting more of these well-designed systems to make writing code more pleasant.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Chronicle of SEP Startup Weekend 2016]]></title>
    <link href="https://larry-price.com/blog/2016/03/03/a-chronicle-of-sep-startup-weekend-2016/"/>
    <updated>2016-03-03T15:16:29-05:00</updated>
    <id>https://larry-price.com/blog/2016/03/03/a-chronicle-of-sep-startup-weekend-2016</id>
    <content type="html"><![CDATA[<p>Last weekend was the 2016 SEP Startup Weekend, a bi-annual hackathon where a few of the engineers get together for 48 hours to build things. As far as most people know, we transform massive quantities of beer, coffee, and unhealthy food into cohesive piles of code. Although that about sums it up, I thought it might be nice to chronicle my team&rsquo;s experience of this season&rsquo;s event. Enjoy!</p>

<h3>The Pitch</h3>

<p>In my first startup weekend since <a href="/blog/2014/07/13/ollert-reveal-the-data-behind-your-trello-boards/">Ollert</a>, I pitched an idea for an instant runoff voting platform called RePoll. RePoll would allow users to create polls, rank candidates, and view results in a login-less system via a web portal, Android, and iOS app. To make it all interesting, I wanted to do all of the coding in javascript by using <a href="http://facebook.github.io/react/">React</a> for the web frontend and <a href="https://facebook.github.io/react-native/">React Native</a> for the iOS and Android apps.</p>

<h3>Friday</h3>

<p>I somehow convinced 3 of my coworkers to help me on Friday night, who I&rsquo;ll refer to as H, G, and K, forming teams by combining the letters.</p>

<p>After sending around a few images and documents with my proposed architecture, I had GH start working together to build the Android app in React Native. Unfortunately, we hit a few snags in getting React Native to run an Android app on actual hardware, but late into the evening everything was up and running on a <a href="https://www.genymotion.com/">genymotion simulator</a>. By the end of the night, GH had a good portion of the <a href="https://facebook.github.io/react-native/docs/tutorial.html#content">React Native opening tutorial</a> completed.</p>

<p>In the meantime, K and myself were hard at work building a core web API in NodeJS for all apps to use. We decided to use Mongo so we didn&rsquo;t have to worry about updating schema and initializing databases, and we used <a href="http://www.getpostman.com/">Postman</a> to test our API calls. I may have overarchitected the session/token-based authorization system, but we got over 50% of the way done with the API. In my initial estimates, I wanted to have the API 100% completed by Friday night, but we were all tired and decided to break for the night around 10p.</p>

<p>Although everyone else headed out the door, the garage was packed with cars leaving a fancy-pants event held near our office. I stayed behind for about an hour setting up our API to run on <a href="https://re-poll.herokuapp.com/">heroku with a MongoDB instance</a>, and then configuring DNS for the domain I had already purchased.</p>

<h3>Saturday</h3>

<p>I arrived early and laid down <a href="https://open.spotify.com/album/0XxLqWttW6u6vP3Yz9Sye3">some sweet jams</a>. I continued working on the API alone and had K start working on the iOS app. We added a new teammate, dubbed A, who started work on the web frontend. The API neared completion by the end of the afternoon, and the mobile apps were beginning to hook into the publicly accessible API. During this time, several bugs were found in the initial API code and were fixed. The iOS app was making quick UI progress, but having issues connecting to the API. I started floating between dev teams as I got drowsy, but eventually got a second wind and started helping with the web frontend. The Android and web applications were both able to create polls before everyone went home. A started using a web React datetime component to set start and end dates, while the Android team was figuring out how to use the native calendar and clock to select dates and times.</p>

<p>To store data, the mobile teams started using the <a href="https://facebook.github.io/react-native/docs/asyncstorage.html">Async Storage</a> library which allows for OS-agnostic storage of data in iOS and Android. On the web frontend, we used local storage to keep around any information we might need.</p>

<p>Near the end of the night as I started working on the poll results page on the web frontend, I started finding system-crashing bugs in my interpretation of instant runoff voting, and eventually found that the results weren&rsquo;t always correct.</p>

<p>One item slowing us down Saturday when writing React Native code was its insistence on using syntax defined in ES2015. Our team was largely unfamiliar with this new syntax, so this tripped us up a bit more than expected. All in all, it was a great learning experience to see this cutting edge specification in action.</p>

<h3>Sunday</h3>

<p>Early again, I created a <a href="https://repoll-web.herokuapp.com/">heroku app for our web frontend</a> and set up the DNS appropriately. As the rest of the team started to pile in (and the smells of bacon arose from the Commons), I transitioned to trying to fix the incorrect ballot-counting logic in the API. I ended up rewriting the code several times, but finally found an algorithm that worked correctly. At this point I was kicking myself for not writing tests to verify we were writing good code.</p>

<p>The Android team caught a second wind, finishing the create poll page and started tackling poll lookup. The original plans called for a typeahead, which ended up being tougher to implement than expected, so the Android app instead supplied a simple textbox to attempt to match an existing poll. In doing this, the Android team successfully created an authentication token in the API and was able to display poll candidates in the app before running out of time.</p>

<p>The iOS team continued to have issues with the API, but successfully mocked out most of the rest of the app right before the demos.</p>

<p>Due to familiarity with the tech, the web team was able to get most of the way to a completed layout. I hastily fashioned a dual-list system for seeing candidates and ballot selection, while A transformed that system into a drag and droppable component. We were able to submit updated ballots to the server and fetch previous ballots for our poll tokens. With the updated API, the results page started working and it became possible to view the steps involved in eliminating candidates during the runoff process.</p>

<p>During demos, we presented all three apps and everyone was quite impressed at our javascripting.</p>

<h3>Action Items</h3>

<ul>
<li><em>General Things</em>

<ul>
<li><strong>Learn more about React Native.</strong> I was largely shielded from the pain as I was working on the API and React web parts of our project, but from what I&rsquo;ve seen and heard React Native is an incredible framework for getting things done and sharing code and code paradigms.</li>
<li><strong>Start using ES2015.</strong> Tools like <a href="https://babeljs.io/">Babel</a> allow us to start using next-generation javascript standards to write code now even if the browser support is unavailable.</li>
<li><strong>Do more with <a href="https://webpack.github.io/">webpack</a> or <a href="http://browserify.org/">browserify</a>.</strong> I want to be able to use these tools to optimize pre-rendering on our site, but we were in such a rush we primarily used webpack to enable us to use several NodeJS dependencies. Still cool, but there&rsquo;s so much else to explore.</li>
</ul>
</li>
<li><em>Startup Weekend</em>

<ul>
<li><strong>Estimate better.</strong> I drastically underestimated the amount of work needed to get this project completed in a weekend. We would have had a better chance had I pre-built the API. I think doing some pre-work in this case would have been okay, but I also could have asked for more help. Next time I would like to do a better job of figuring out how much work there is and how much time it will take.</li>
<li><strong>Be an expert.</strong> About half the work we did this weekend was in unknown territory for me. I should have studied further on getting React Native working before the event, and I should have known a little bit more about ES2015 as well. Although the lack of expertise slowed us down a bit, my teammates were extremely adaptive and loved learning the new tech.</li>
<li><strong>Create and prep the team beforehand.</strong> I had enlisted one engineer before the pitches Friday night, and I ran my presentation through that engineer to verify it all made sense. I should have also run some of my architecture ideas past that engineer to get buy-in. I also wouldn&rsquo;t mind having the team mostly formed before we start, but that&rsquo;s a big commitment to ask of people.</li>
<li><strong>Take more frequent, shorter breaks.</strong> We hit the Monon Saturday afternoon and walked for 30-40 minutes which ended up making me drowsy. However, the fresh air did us some good and was revitalizing for the project in general. It would be great to have more frequent, 10-15 minute walks, but it&rsquo;s really difficult to find a time when the team is ready to take a group break in such a fast-paced environment.</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
