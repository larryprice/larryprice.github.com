<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-02-22T16:45:19-05:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Convincing rvm to let you use ruby 2.1.0]]></title>
    <link href="http://larry-price.com/blog/2014/02/22/convincing-rvm-to-let-you-use-ruby-2-dot-1-0/"/>
    <updated>2014-02-22T16:46:00-05:00</updated>
    <id>http://larry-price.com/blog/2014/02/22/convincing-rvm-to-let-you-use-ruby-2-dot-1-0</id>
    <content type="html"><![CDATA[<p><a href="//ruby-lang.org/en/news/2013/12/25/ruby-2-1-0-is-released/">Ruby 2.1.0 went stable</a> a few months ago, and <a href="//ruby-lang.org/en/news/2014/01/10/ruby-1-9-3-will-end-on-2015/">Ruby 1.9.3 support</a> will end in a just over a year.</p>

<p>You know what that means: Warplanes in the sky falling to the ground, dogs and cats getting along like old pals, and people wandering aimlessly through the streets trying to remember the last time they saw a green build.</p>

<p>Believe it or not, all of these things can be prevented. Once upon a time, I wrote about <a href="/blog/2013/10/08/rvm-quick-start/">configuring and using rvm</a> to control individual ruby environments for each of your projects. If it&rsquo;s been a while since you installed your copy of <a href="//rvm.io/">rvm</a>, you might have some trouble installing and using newer version of ruby. Lucky for us, those clever rvm developers made it easy to get around this.</p>

<p>In my case, I want to upgrade a project to use <code>ruby 2.1.0</code>. The first time I tried to run <code>rvm install ruby-2.1.0</code>, I ended up installing <code>ruby-2.1.0-preview1</code>. I realized that I had installed rvm on this machine around October 2013, and <code>ruby 2.1.0</code> was released in December 2013, so rvm had no idea that <code>ruby 2.1.0</code> was stable. Updating rvm (in the root of the project directory):</p>

<p><code>bash /home/lrp/Projects/2014/projNeedingRuby210
$ rvm get stable
</code></p>

<p>There will be some amount of text on the screen if your system needs to be updated. Note that you must be connected to the internet if you want rvm to update. Now we do the install of our brand new ruby:</p>

<p><code>bash /home/lrp/Projects/2014/projNeedingRuby210
$ rvm install ruby-2.1.0
</code></p>

<p>Again, text on the screen from fetching of data from the internet. But hopefully you see something that tells you the operation was successful. You can also verify which rubies you have installed using the <code>list</code> command:</p>

<p>``` bash /home/lrp/Projects/2014/projNeedingRuby210
$ rvm list rubies
   ruby-1.9.3-p448 [ x86_64 ]
=> ruby-2.0.0-p247 [ x86_64 ]
 * ruby-2.1.0 [ x86_64 ]</p>

<h1>=> &ndash; current</h1>

<h1>=* &ndash; current &amp;&amp; default</h1>

<h1>* &ndash; default</h1>

<p>```</p>

<p>Now we tell our current project to use <code>ruby 2.1.0</code>:</p>

<p><code>bash /home/lrp/Projects/2014/projNeedingRuby210
$ rvm use ruby-2.1.0
$ which ruby
/home/lrp/.rvm/rubies/ruby-2.1.0/bin/ruby
</code></p>

<p>Alright! Crisis averted. If you&rsquo;re using <a href="//bundler.io/">bundler</a> with this project, be sure to change your ruby version (usually located near the top of the <code>Gemfile</code>).</p>

<p>What about setting up a new project using <code>ruby 2.1.0</code>? Easy! Switch to the project directory and:</p>

<p><code>bash /home/lrp/Projects/2014/newRubyProject
$ rvm 2.1.0@newRubyProject --create --ruby-version
</code></p>

<p>Oh, rvm, you make life <em>too</em> easy sometimes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RVM Quick Start]]></title>
    <link href="http://larry-price.com/blog/2013/10/08/rvm-quick-start/"/>
    <updated>2013-10-08T22:10:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/10/08/rvm-quick-start</id>
    <content type="html"><![CDATA[<p>When I was working on a few different projects at once, I started running into issues where my Ruby gem versions would start to mismatch. How did I fix that issue? Naively. I adjusted the versions as necessary so my gems were always the same version. That was&hellip; pretty dumb. To make up for my past ignorance, I&rsquo;ve been exploring ways to manage my Ruby versions and my gems intelligently. Enter <a href="https://rvm.io/">RVM</a>.</p>

<p>RVM is a simple tool to solve just problems. And it works pretty well. I hit some kinks along the way, but my installation pleases me well enough. Getting RVM is not for the faint of heart. Maybe there are better ways to do it, but the website says to execute the following:</p>

<p>``` bash /home/lrp/my_project</p>

<blockquote><p>curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
```</p></blockquote>

<p>This command uses curl to fetch the data that lives at <code>https://get.rvm.io</code>, which happens to be a big bash script. It executes the bash script with the args <code>-s stable</code>. &lsquo;Stable&rsquo; means the latest stable release of RVM. I could just as easily give it &lsquo;dev&rsquo; and get the latest developer release instead, but I really don&rsquo;t want that. So that command does a lot of stuff and may give you some further instructions to run before you can continue. Use that big head of yours and follow the instructions. You may also need to restart a terminal to get RVM to be recognized as a command. Since I was using <code>gnome-terminal</code>, I had to follow these <a href="https://rvm.io/integration/gnome-terminal">instructions</a>.</p>

<p>Now I want RVM to know about some Ruby versions. For a full list of possible Ruby versions to install, run <code>rvm list known</code>. I just want 1.9.3. I found that I needed to do this even though I had 1.9.3 installed on my system previously.</p>

<p>``` bash /home/lrp/my_project</p>

<blockquote><p>rvm install ruby-1.9.3
```</p></blockquote>

<p>In Ubuntu 13.04, this command installs ruby-1.9.3 in <code>~/.rvm/rubies/ruby-1.9.3-p448/bin/ruby</code>. I&rsquo;ve found that this also sets my default Ruby to the RVM version of Ruby, which I don&rsquo;t want. To verify and undo this, I executed the following commands outside of my project directory.</p>

<p>``` bash /home/lrp</p>

<blockquote><p>which ruby
/home/lrp/.rvm/rubies/ruby-1.9.3-p448/bin/ruby
echo &ldquo;D'oh&rdquo;
D'oh
rvm use system
Now using system ruby.
which ruby
/usr/bin/ruby</p>

<p>```</p></blockquote>

<p>Now that that&rsquo;s settled, I want to tell RVM to use the local version of Ruby for my project and to install any gems in a special location.</p>

<p>``` bash /home/lrp/my_project</p>

<blockquote><p>rvm 1.9.3@my-project &mdash;create &mdash;ruby-version
```</p></blockquote>

<p>This creates a gemset and ruby-version file (<code>.ruby-gemset</code> and <code>.ruby-version</code> files) using the Ruby installation 1.9.3 created above. I specifiy to use <code>--ruby-version</code> instead of <code>--rvmrc</code> because RVM told me that I should. After some research, the <code>.ruby-version</code> file is used by several other tools, so this will keep my potential number of config files low. Now I check that all my Ruby versions are okay.</p>

<p>``` bash /home/lrp/my_project</p>

<blockquote><p>which ruby
/home/lrp/.rvm/rubies/ruby-1.9.3-p448/bin/ruby
cd ..
which ruby
/usr/bin/ruby</p>

<p>```</p></blockquote>

<p>When in my project directory, all the gems I install will be installed to my specified gemset, which means they are no longer cluttering my global gemspace, even when I install them using Bundler. It also means that I can use ruby-1.9.3 for this project and 2.0 for another project with minimal mental overhead. This makes me a happy developer.</p>

<p>I only glazed over the installation process and documentation for RVM. Go to <a href="https://rvm.io/">the web site</a> for more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Foreman to Create an Upstart Service]]></title>
    <link href="http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service/"/>
    <updated>2013-08-31T17:05:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/31/using-foreman-to-create-an-upstart-service</id>
    <content type="html"><![CDATA[<p>I just finished my first attempt at deploying a web app to run automatically in the background on a friend&rsquo;s server. Pretty easy, really. The first thing I did was install <a href="https://github.com/ddollar/foreman">foreman</a>. Assuming you have ruby and rubygems installed:</p>

<p><code>bash
$ sudo gem install foreman
</code></p>

<p>Next I needed to give foreman the commands to start my app. I created a file in the root of my project directory called &lsquo;Procfile&rsquo; and gave it the steps I would run to start my app manually. For the sake of simplicity, let&rsquo;s say I run my app pretty barebones:</p>

<p><code>bash Procfile
web: bundle exec rackup
</code></p>

<p>Now when I run <code>foreman start</code>, foreman will use <a href="http://bundler.io/">Bundler</a> to execute rackup with the correct gems in my Gemfile. Now exporting upstart config files is pretty easy.</p>

<p><code>bash
$ sudo foreman export upstart --app=MyApp --user=root /etc/init
</code></p>

<p>That command creates the .conf files needed for upstart to control the service called &lsquo;MyApp&rsquo; as the user &lsquo;root.&rsquo; It puts all the .conf files in <code>/etc/init</code> (which is where Ubuntu puts such things) and will create a default log directory in <code>/var/log/MyApp</code>. Now I can control my service by running <code>service MyApp start</code>, <code>service MyApp stop</code>, <code>service MyApp restart</code>, and <code>service MyApp status</code>. Hooray for me.</p>

<p>But I need to run my app in two ways: in dev mode on a local port with my dev database, and I need to run it in production mode using port 80 and the production database. I&rsquo;ve also heard that using <a href="https://en.wikipedia.org/wiki/WEBrick">webrick</a> (the default server installed with rackup) is great for develpment, but I should be using something else for my production server. So I made some config files for foreman:</p>

<p><code>bash development.env
RACK_ENV=development
PORT=9292
SERVER=rackup
</code></p>

<p><code>bash production.env
RACK_ENV=production
PORT=80
SERVER=unicorn
</code></p>

<p>And I change my Procfile to:</p>

<p><code>bash Procfile
web: bundle exec $SERVER -p $PORT -E $RACK_ENV
</code></p>

<p>Ridiculously configured. Now when I run <code>foreman start</code>, it will error out. I need to specify my environment file:</p>

<p><code>bash
$ foreman start -e production.env
</code></p>

<p>Now foreman will use Bundler to startup the server specified in <code>$SERVER</code>, run the app on port <code>$PORT</code> (-p), and will pass through the environment listed as <code>$RACK_ENV</code> to my application (-E), allowing my app to do whatever configuration it does given the current environment. Power to the people.</p>

<p><a href="http://michaelvanrooijen.com/articles/2011/06/08-managing-and-monitoring-your-ruby-application-with-foreman-and-upstart/">I found that this guy</a> does a lot more complicated stuff with Foreman, if you need more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the Futility of Man and Trying to Divide a Sinatra App into Separate Controllers]]></title>
    <link href="http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers/"/>
    <updated>2013-08-26T22:35:00-04:00</updated>
    <id>http://larry-price.com/blog/2013/08/26/on-the-futility-of-man-and-trying-to-divide-a-sinatra-app-into-separate-controllers</id>
    <content type="html"><![CDATA[<p>Oh, <a href="http://www.sinatrarb.com/">Sinatra</a>. You&rsquo;re oh-so-very dear to me. You made it so easy for me to write my <a href="http://capitalpunishment.herokuapp.com">first</a> <a href="http://pokephile.herokuapp.com">web</a> apps. All I had to do was write a couple routes and throw together a few HTML-like files and I had a web app. I used pattern matching to reduce the web-facing code for <a href="https://github.com/larryprice/CapitalPunishment">Capital Punishment</a> from ~500 lines of code to &lt;100 lines of code. You are perfect for writing small-time web applications.</p>

<p>But what about large web applications? What about a web app that has normal users and admin users, makes lots of database reads and writes (my previous apps only did reads from a user-facing perspective), and has to be able to show the history of everything, forever, to the authorized users who request it?</p>

<p>You see, Sinatra is kind of an <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC framework</a>, but not exactly. In Sinatra, you have Views (your HTML inter-mixed with Ruby code in your desired DSL) and you have Controllers (each of your routes). When a database is involved, you can use something like <a href="https://github.com/bmizerany/sinatra-activerecord">ActiveRecord</a> or <a href="http://mongoid.org/en/mongoid/index.html">Mongoid</a> or <a href="http://datamapper.org/">DataMapper</a> and you have yourself Models.</p>

<p>So every route is kind of a Controller. Every. Route. In Capital Punishment, there were once 8 routes (there are now 7). In the project I&rsquo;ve been working on recently, there are currently 56 routes. 56 routes in the language described above means I kind of have 56 controllers.</p>

<p>That&rsquo;s been pretty overwhelming, especially since the traditional way of creating routes in Sinatra is to shove them all in the same file. There are a few ways I could think of to address this. The way we chose six months ago (for better or worse) was found <a href="http://stackoverflow.com/questions/5877000/what-is-a-controller-in-sinatra">on StackOverflow</a>, and involves creating a bunch of different files where you shove all related routes. So you get this situation:</p>

<p>``` ruby app.rb
class App &lt; Sinatra::Base
end</p>

<p>require_relative &lsquo;controllers/helpers&rsquo;</p>

<p>Dir.glob(&ldquo;#{File.dirname(<strong>FILE</strong>)}/controllers/*.rb&rdquo;).each do |file|
  require file.chomp(File.extname(file))
end</p>

<p>class App
  get &lsquo;/&rsquo; do</p>

<pre><code>erb :home
</code></pre>

<p>  end
end
```</p>

<p>``` ruby controllers/reports_controller.rb
class App
  get &lsquo;/reports/user_bills&rsquo; do</p>

<pre><code>erb :user_bills_report
</code></pre>

<p>  end
  &hellip;
end
```</p>

<p>And so on and so forth. This works fine for a while, but we&rsquo;ve ended up with 13 &ldquo;controller&rdquo; files, many of which are not trivial. This also makes the App class quite large since its controllers handle most of the logic for the app. This also doesn&rsquo;t enforce any kind of URL-naming logic, so if a developer is working hard (s)he may create both <code>/reports/user_bills</code> and <code>user_info_reports</code> without realizing the inconsistency (s)he just injected into the system.</p>

<p>In hindsight, this method is not perfect. I think that the Rails method of individual controllers is significantly better for large apps. Some people have been using other methods for trying to make Sinatra more MVC, such as <a href="https://github.com/jorrizza/sinatra-mvc">sinatra-mvc</a>. To be frank, sinatra-mvc pretty much does the same thing we&rsquo;ve done, but with more structure.</p>

<p>I think what I&rsquo;ve learned is that you should use a tool for its intended purpose. Sinatra was written to quickly create web apps in Ruby with minimal effort. Once you have more than 10-15 routes, you should reconsider whether your app can still be called &ldquo;minimal effort.&rdquo; Sinatra may fly you to the moon, but you&rsquo;re unlikely to see what spring is like on Jupiter or Mars.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pushing an Application to Heroku that Uses Ruby and Mongo]]></title>
    <link href="http://larry-price.com/blog/2013/01/20/pushing-an-application-to-heroku-that-uses-ruby-and-mongo/"/>
    <updated>2013-01-20T11:55:00-05:00</updated>
    <id>http://larry-price.com/blog/2013/01/20/pushing-an-application-to-heroku-that-uses-ruby-and-mongo</id>
    <content type="html"><![CDATA[<p><em>This is Part 3 in a multi-part series to detail the creation of a &ldquo;simple&rdquo; project combining <a href="http://www.ruby-lang.org/">Ruby</a>, <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://rspec.info/">RSpec</a>, <a href="http://www.sinatrarb.com/">Sinatra</a>, and <a href="https://github.com/jnicklas/capybara">Capybara</a> in preperation for a larger-scale side project set to begin January 2013. For more in this series, see the <a href="/blog/categories/pokephile">Pokephile category</a>. Part 4 of this series details moving from a development environment to a production environment using <a href="http://heroku.com/">Heroku</a>. The code for this side-project is located <a href="https://github.com/larryprice/Pokephile">on Github</a>, and the final product can be found <a href="http://pokephile.herokuapp.com">here</a>.</em></p>

<p><a href="http://heroku.com/">Heroku</a> is a hosting service for different types of web applications. The best thing about Heroku is it&rsquo;s free, you get a decent subdomain for your application, and there&rsquo;s no spam email. Go ahead and <a href="http://api.heroku.com/signup">sign up</a> if you don&rsquo;t already have an account.</p>

<p>Now we need the Heroku Toolbelt. I&rsquo;ll illustrate for Ubuntu 12.10, but there&rsquo;s also <a href="https://toolbelt.heroku.com/">documentation for installing on any OS</a>.</p>

<p><code>bash
$ wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh | sh
</code></p>

<p>The toolbelt installs some Heroku-specific applications in addition to ensuring you have Foreman and <a href="http://git-scm.com/">Git</a> on your system. Now it&rsquo;s time to tell the Heroku Toolbelt who we are.</p>

<p><code>bash Step 3 - Modified Excerpt from the Heroku Getting Started guide
$ heroku login
Enter your Heroku credentials.
Email: larry@example.com
Password:
Could not find an existing public key.
Would you like to generate one? [Yn]
Generating new SSH public key.
Uploading ssh public key /home/larry/.ssh/id_rsa.pub
</code></p>

<p>In order for Heroku to figure out what ruby gems are needed to run your application, you need to specify a Gemfile. It&rsquo;s wise to specify a specific version of Ruby, and it&rsquo;s also a good idea to keep the gems' versions close to the state you developed with. For the <a href="/blog/categories/pokephile">Pokephile</a> application created in this series, this is my Gemfile:</p>

<p>``` ruby project/Gemfile
source :rubygems</p>

<p>ruby &lsquo;1.9.3&rsquo;</p>

<p>gem &lsquo;sinatra&rsquo;, &lsquo;~>1.3.2&rsquo;
gem &lsquo;haml&rsquo;, &lsquo;~>3.1.6&rsquo;
gem &lsquo;mongoid&rsquo;, &lsquo;~>3.0.14&rsquo;</p>

<p>group :development, :test do</p>

<pre><code>gem 'capybara', '~&gt;2.0.1'
gem 'rspec', '~&gt;2.11.0'
gem 'nokogiri', '~&gt;1.5.5'
</code></pre>

<p>end
```</p>

<p>First I specify a source for my gems: &lsquo;rubygems&rsquo; defaults to &ldquo;<a href="http://rubygems.org">http://rubygems.org</a>&rdquo; and hasn&rsquo;t failed me yet. Next I specify that I want to use Ruby 1.9.3, a necessity because Mongoid 3.x doesn&rsquo;t work correctly with 1.9.2. The versions of the first three gems were chosen by typing the following in the command line to determine which version I had installed on my machine:</p>

<p><code>bash
$ gem query | grep 'sinatra\|haml\|mongoid'
haml (3.1.7, 3.1.6)
mongoid (3.0.17, 3.0.15, 3.0.14)
sinatra (1.3.3, 1.3.2)
sinatra-contrib (1.3.2)
sinatra-reloader (1.0)
</code></p>

<p>The &lsquo;~>&rsquo; operator tells Bundler to use greater-than-equal but stop before next highest version. So, for Sinatra &lsquo;~>1.3.2&rsquo; means that Bundler will accept anything greater-than-or-equal-to &lsquo;1.3.2&rsquo; and less than &lsquo;1.4.0.&rsquo; I tend to rely on the &lsquo;~>&rsquo; operator so I can be sure no APIs are changed in my gems.</p>

<p>The next block is a conditional checking in which environment the gems are being installed. This defaults to :development if none is specified. I put the gems used for testing in this block since they&rsquo;re not needed to run the application, but a developer/tester would need these to run the tests.</p>

<p>For this Gemfile to be meaningful, we need to use a program called <a href="http://gembundler.com/">Bundler</a> to &ldquo;bundle&rdquo; the gems and their dependencies in a Gemfile.lock file.</p>

<p><code>bash
$ pwd
project/
$ sudo apt-get install bundler
...
$ bundle install
...
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
</code></p>

<p>Running bundler will create a Gemfile.lock file and make sure your system has the specified gems. If some gems are missing or need new versions to be installed, bundler will ask the user for their password to get the required gems.</p>

<p>The next step for setting things up is to set up Git. If your application is already using Git, you only need to commit all files to verify that the Gemfile and Gemfile.lock make it into the repository.</p>

<p><code>bash
$ cd project/
$ git init
$ git add .
$ git commit -m "Initial commit."
</code></p>

<p>Now we create a Heroku project and give it a meaningful name. If you can&rsquo;t think of a meaningful name, use &lsquo;heroku create&rsquo; and Heroku will come up with something for you.</p>

<p><code>bash
$ heroku create meaningful-name
Creating meaningful-name... done, stack is cedar
http://meaningful-name.herokuapp.com/ | git@heroku.com:meaningful-name.git
Git remote heroku added
</code></p>

<p>We&rsquo;re almost there. Because we included accessing Mongo databases in our application, we have to take care of that on the web. The easiest way to do that is using a Heroku Add-on. At this time, there are two major Heroku Add-ons for Mongo databases: <a href="https://addons.heroku.com/mongolab">MongoLab</a> and <a href="https://addons.heroku.com/mongohq">MongoHQ</a>. Both services have a starter service for $0/month, which is pretty awesome in my opinion. I flipped a coin and picked MongoLab for this application. Adding the add-on to our project:</p>

<p><code>bash
$ heroku addons:add mongolab:starter
</code></p>

<p>If you haven&rsquo;t already, Heroku will ask you to &ldquo;verify your account&rdquo; before continuing. This means that you have to put in some credit card information. Note that you will not be charged, I guess Heroku just wants some indication that you might eventually pay for something. After you put in your credit card information, you may need to run the above command again.</p>

<p>Now that MongoLab is set up on the server-side, we need to tell Mongoid how to connect to that server. The following command will give you the environment variable needed to connect to the server:</p>

<p><code>bash
$ heroku config | grep MONGOLAB_URI
</code></p>

<p>Now we update our mongoid.yml file to use that string:</p>

<p>``` yml project/mongoid.yml
development:
  sessions:</p>

<pre><code>default:
  database: dev
  hosts:
    - localhost
</code></pre>

<p>  options:</p>

<p>test:
  sessions:</p>

<pre><code>default:
  database: test
  hosts:
    - localhost
</code></pre>

<p>production:
  sessions:</p>

<pre><code>default:
  uri: &lt;%= ENV['MONGOLAB_URI'] %&gt;
  options:
    skip_version_check: true
    safe: true
</code></pre>

<p>```</p>

<p>Because of the way my application works, I want to prepopulate the database with some Pokemon.</p>

<p><code>`` bash
$ export MONGOLAB_URI=</code>heroku config | grep MONGOLAB_URI | cut -c 15-`
$ pwd
project/
$ cd tools/populate
$ irb</p>

<blockquote><blockquote><p>require &lsquo;./populater&rsquo;
true
require &lsquo;mongoid&rsquo;
true
Mongoid.load! &lsquo;../../mongoid.yml&rsquo;, :production
{&ldquo;sessions&rdquo;=>{&ldquo;default&rdquo;=>{&ldquo;uri&rdquo;=>nil, &ldquo;options&rdquo;=>{&ldquo;skip_version_check&rdquo;=>true, &ldquo;safe&rdquo;=>true}}}}
Populater.new.add_pokemon 1000
nil
```</p></blockquote></blockquote>

<p>With the production database populated, we need to set an environment variable in our production application defining the environment.</p>

<p><code>bash
$ heroku config:add MONGOID_ENV=production
</code></p>

<p>Now that we&rsquo;ve made changes to the mongoid.yml file, we should commit again and push to Heroku.</p>

<p><code>bash
$ git commit -a -m "Updating mongoid.yml file for production"
...
$ git push heroku master
</code></p>

<p>And that&rsquo;s it! Check your Heroku URL to make sure everything looks okay and call it a day, or make some upgrades as I did for my <a href="http://pokephile.herokuapp.com">personal version of this project</a>.</p>
]]></content>
  </entry>
  
</feed>
