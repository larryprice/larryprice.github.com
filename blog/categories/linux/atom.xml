<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Larry Price]]></title>
  <link href="http://larryprice.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://larryprice.github.io/"/>
  <updated>2014-01-07T20:45:16-05:00</updated>
  <id>http://larryprice.github.io/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setting up a Go environment in Ubuntu]]></title>
    <link href="http://larryprice.github.io/blog/2013/12/15/setting-up-a-go-environment-in-ubuntu-12-dot-04/"/>
    <updated>2013-12-15T18:40:00-05:00</updated>
    <id>http://larryprice.github.io/blog/2013/12/15/setting-up-a-go-environment-in-ubuntu-12-dot-04</id>
    <content type="html"><![CDATA[<p>Some very light cajoling led me to do some investigation into <a href="http://golang.org/">Google Go</a> (often called <strong>golang</strong> for ease of internet search). This is a brief recounting of how I got up and running on <a href="http://ubuntu.com">Ubuntu</a> (first 12.04 and then 13.10). Luckily, this has been made espcially easy for us with the introduction of a <a href="http://packages.ubuntu.com/precise/golang">golang package in the Ubuntu package repositories</a>. There are also <a href="http://golang.org/doc/install">official installation instructions</a> if you don&rsquo;t like mine.</p>

<p>Open up a terminal and let loose:</p>

<p><code>bash
$ sudo apt-get install golang
</code></p>

<p>The download is pretty heavy, so this step may take some time. Eventually the installer for <code>golang-go</code> will ask you if you want to &ldquo;Report installation of public packages to Go Dashboard.&rdquo; I&rsquo;ve been choosing &ldquo;No&rdquo; to this question and have no complaints.</p>

<p>Now comes the fun part. Serious Go development relies on having a &ldquo;workspace&rdquo; setup involving a specific directory structure including <code>bin/</code>, <code>pkg/</code>, and <code>src/</code> directories. Google&rsquo;s <a href="http://golang.org/doc/code.html">official set-up page</a> contains more information about these workspaces.</p>

<p>I&rsquo;m not a big fan of putting a visible directory in <code>$HOME</code>, so I opted to make a hidden directory called <code>.go</code>. After creating the directory, the environment variable <code>$GOPATH</code> needs to be set and <code>$PATH</code> needs to be adjusted.</p>

<p><code>bash
$ mkdir ~/.go
$ echo "GOPATH=$HOME/.go" &gt;&gt; ~/.bashrc
$ echo "export GOPATH" &gt;&gt; ~/.bashrc
$ echo "PATH=\$PATH:\$GOPATH/bin # Add GOPATH/bin to PATH for scripting" &gt;&gt; ~/.bashrc
$ source ~/.bashrc
</code></p>

<p>Now I&rsquo;m going to create a go project and add a link to it in the workspace I just created.</p>

<p><code>bash
$ mkdir -p $GOPATH/src/github.com/user
$ mkdir ~/hello-go
$ ln -s ~/hello-go ~/.go/src/github.com/user/hello-go
</code></p>

<p>For some actual test code, I&rsquo;ll add a file in my <code>hello-go/</code> directory called <code>hello.go</code> with the following code:</p>

<p>``` go hello.go
package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
  fmt.Println(&ldquo;Hello world&rdquo;)
}
```</p>

<p>Now I&rsquo;m going to install the binary created from compiling this code into my <code>$GOPATH</code> to verify that my workspace is set up correctly, then I&rsquo;ll run it to behold the fruit of my efforts.</p>

<p><code>bash
$ go install github.com/user/hello-go
$ hello-go
Hello world
</code></p>

<p>Installing is not necessary every time I want to test that my code compiles; running <code>go build</code> in the source directory will create a local executable that can be executed for incremental testing.</p>

<p>If you&rsquo;re interested in learning golang, I would recommend doing the <a href="http://tour.golang.org/">go tour</a>. It goes way beyond a trivial hello world program and gives you some insight into many coplex go concepts (I even posted <a href="https://gist.github.com/larryprice/7647808">my solutions as a gist</a>, if you&rsquo;re interested).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Login shell not sourcing .bashrc: A brief lesson in dot-files]]></title>
    <link href="http://larryprice.github.io/blog/2013/12/10/login-shell-not-sourcing-bashrc/"/>
    <updated>2013-12-10T19:45:00-05:00</updated>
    <id>http://larryprice.github.io/blog/2013/12/10/login-shell-not-sourcing-bashrc</id>
    <content type="html"><![CDATA[<p>I have a confession: I&rsquo;ve been avoiding using <a href="https://rvm.io/">rvm</a> for the past few weeks for stupid reasons.</p>

<p>When using <code>rvm</code> with <code>gnome-terminal</code>, I have to tell <code>gnome-terminal</code> to run as a login shell so that <code>/etc/profile</code> is sourced. The login shell is then supposed to source <code>$HOME/profile</code>, which is then supposed to source <code>$HOME/.bashrc</code>. Installing <code>rvm</code> results in me editing my <code>.bash_profile</code> to add the following line:</p>

<p><code>bash .bash_profile
[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
</code></p>

<p>All my <code>rvm</code> environments seem to work, so this is a success, right?</p>

<p>Well, I type the good ol' <code>ls</code> command and I notice that all my colors are missing. I notice that the terminal title no longer reads the present working directory, but instead greets me with a disinterested &ldquo;Terminal.&rdquo; What happened?</p>

<p>Eventually I realized that this was a problem caused by not sourcing my <code>.bashrc</code>. Where did I go wrong?</p>

<p>The login shell sources <code>$HOME/.profile</code> UNLESS <code>$HOME/.bash_profile</code> exists, in which case it only sources the latter. So what are the contents of my <code>$HOME/.profile</code>?</p>

<p>``` bash .profile</p>

<h1>~/.profile: executed by the command interpreter for login shells.</h1>

<h1>[cut for brevity]</h1>

<h1>if running bash</h1>

<p>if [ -n &ldquo;$BASH_VERSION&rdquo; ]; then</p>

<pre><code># include .bashrc if it exists
if [ -f "$HOME/.bashrc" ]; then
  . "$HOME/.bashrc"
fi
</code></pre>

<p>fi</p>

<h1>[cut for brevity]</h1>

<p>```</p>

<p>Aha! The sneaky dot-file actually sources <code>$HOME/.bashrc</code>, and my shiny new <code>$HOME/.bash_profile</code> doesn&rsquo;t. I fixed this by sourcing <code>$HOME/.profile</code> in <code>$HOME/.bash_profile</code>.</p>

<p><code>bash .bash_profile
[ -f "$HOME/.profile" ] &amp;&amp; source "$HOME/.profile"
[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
</code></p>

<p>For the memory-impaired: <code>.bash_profile</code> sources <code>.profile</code> sources <code>.bashrc</code>.</p>

<p>Re-open <code>gnome-terminal</code> to find my colors are fixed, my title is correct, and <code>rvm</code> plays the right notes. The world is at peace once again, and I don&rsquo;t have to avoid using <code>rvm</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Linux Works: What Every Superuser Should Know]]></title>
    <link href="http://larryprice.github.io/blog/2012/11/26/how-linux-works-what-every-superuser-should-know/"/>
    <updated>2012-11-26T21:27:00-05:00</updated>
    <id>http://larryprice.github.io/blog/2012/11/26/how-linux-works-what-every-superuser-should-know</id>
    <content type="html"><![CDATA[<p><img src="http://books.gigaimg.com/avaxhome/77/6b/000c6b77_medium.jpeg" style="border: 0" width="130px" title="How Linux Works" alt="Cover for How Linux Works" /><br/>
<a href="http://www.amazon.com/gp/product/1593270356/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1593270356&amp;linkCode=as2&amp;tag=larpriandthee-20"><strong>How Linux Works: Things Every Superuser Should Know</strong></a><br/>
<strong>Brian Ward</strong></p>

<hr />

<h3>The Gist</h3>

<p>Linux is a complicated operating system which gives its users the freedom to do anything. This book details things that any Linux superuser should be aware of, including printing, networking, scripting, compiling source code, setting up users, and buying hardware.</p>

<h3>My Feelings</h3>

<p>I&rsquo;ve been running <a href="http://ubuntu.com/">Ubuntu</a> as the only operating system on my home computer since the 11.04 Natty Narwhal release in 2011, and I&rsquo;ve been using Ubuntu in varying degrees since 9.04 Lucid Lynx. I&rsquo;ve also recently ported my wife&rsquo;s computer over to Ubuntu after she finally got fed up with Linux. There is a course at Purdue called ECE364 that taught us lots of cool Linux commands which I had forgotten, so I&rsquo;ve been looking for a good refresher. This book helped jog my memory of things like grep, sed, and awk. The book also provided lots of information on things that I&rsquo;d been using for years without really realizing what I was doing.</p>

<p>This book was written in 2004, which was a long time ago in the computing world. In 2004, Ubuntu Linux (<a href="http://www.pcworld.com/article/254516/which_linux_distro_is_fairest_of_them_all_ubuntu_survey_says.html">the most popular personal desktop Linux distribution</a>) was released. Ward makes mentions of setting up network interfaces, firewalls, and printers through the terminal, which are all things that now are either done automatically by most operating systems or at a minimum have a GUI to support setup. Ward also mentions that <a href="http://en.wikipedia.org/wiki/Cathode_ray_tube">CRT monitors</a> are on the cheap, but if you want the best resolution an <a href="http://en.wikipedia.org/wiki/Lcd">LCD monitor</a> is the new cool thang. He talks about <a href="http://en.wikipedia.org/wiki/Pentium">Pentium processors</a>, half gigabytes of DDR, and slow, heavy laptops. Be warned that you won&rsquo;t find anything in this book about 64-bit processors, SSDs, or cloud computing.</p>

<p>Most of the book is still very relevant. As mentioned previously, I got a lot of benefit from reading the section on common commands. The section on setting up dot-files was also extremely useful for me. There was also a lot of interesting information about the Linux filesystem being databases that I had never really thought about before.</p>

<h3>Who Would Like This</h3>

<p>Those new to Linux or those needing a refresher would benefit from scanning this book, at least the interesting sections. This book is not for people looking for bleeding-edge information on their new hardware or software. The reader can get a large amount of information that has aged well and will continue to be relevant for Linux users for years to come.</p>
]]></content>
  </entry>
  
</feed>
