<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xml | Larry Price]]></title>
  <link href="https://larry-price.com/blog/categories/xml/atom.xml" rel="self"/>
  <link href="https://larry-price.com/"/>
  <updated>2018-02-02T16:22:12-06:00</updated>
  <id>https://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    <email><![CDATA[larry@larry-price.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XML Parsing in Go]]></title>
    <link href="https://larry-price.com/blog/2015/12/04/xml-parsing-in-go/"/>
    <updated>2015-12-04T15:30:14-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/04/xml-parsing-in-go</id>
    <content type="html"><![CDATA[<p>Need to parse an XML file in go? XML (en|de)coding is build into go&rsquo;s standard library. Basic parsing of nodes and embedded nodes is straightforward, but there are some interesting things to think about when you need to parse attributes, lists, and if you don&rsquo;t want to create new structs all over the place.</p>

<p>For this exercise, let&rsquo;s look at the following XML document:</p>

<pre><code class="xml">&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;
</code></pre>

<h3>Defining a Data Structure</h3>

<p>The simplest node to parse is going to be <code>&lt;name&gt;</code>. We&rsquo;ll need an object to unmarshal the XML into, which we&rsquo;ll call <code>Person</code>. Every field on <code>Person</code> will be evaluated by the XML encoder to be populated based on the field&rsquo;s name. However, our struct field names and node names don&rsquo;t usually correspond that simply. Because of this, we&rsquo;ll use <code>xml</code> struct tags to identify how to map each node to a go field. Here&rsquo;s an example for <code>&lt;name&gt;</code>:</p>

<pre><code class="go">type Person struct {
  Name string `xml:"name"`
}
</code></pre>

<p>The next node contains a list of <code>&lt;address&gt;</code> nodes. For an address node, we&rsquo;ll have to create a similar struct with <code>City</code> and <code>Street</code> fields:</p>

<pre><code>type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
}
</code></pre>

<p>While parsing each <code>Address</code>, we also want to find the <code>type</code> of address, which can be found as an attribute on the <code>&lt;address&gt;</code> node. By adding <code>attr</code> to our XML struct tag, we can properly parse the <code>type</code> field as well:</p>

<pre><code class="go">type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
    Type string   `xml:"type,attr"`
}
</code></pre>

<p>A <code>Person</code> has a list of <code>Address</code>es. Since we know that <code>address</code> is a direct descendant, we can use the <code>&gt;</code> keyword to parse each <code>&lt;address&gt;</code> from <code>&lt;addresses&gt;</code> into an embedded struct on our <code>Person</code> struct.</p>

<pre><code class="go">type Person struct {
    Name string         `xml:"name"`
    Addresses []Address `xml:"addresses&gt;address"`
}
</code></pre>

<p>This code will work to parse the original document, but do we really need to define a formal struct for addresses? If there was only one address, we could put all the fields directly on the <code>Person</code> struct. However, since we&rsquo;re dealing with a list, our best option is to use an anonymous struct:</p>

<pre><code class="go">type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}
</code></pre>

<h3>Binding the Data Structure</h3>

<p>We can use the <a href="https://golang.org/pkg/encoding/xml/">encoding/xml</a> package to decode the given XML. Given that our raw XML document is stored in a <code>[]byte</code> called <code>document</code>, we&rsquo;ll use <code>xml.Unmarshal</code> to bind our data structure to the XML document:</p>

<pre><code class="go">var luann Person
xml.Unmarshal(document, &amp;luann)
</code></pre>

<h3>Final Code</h3>

<p>Let&rsquo;s put it all together, including a <code>main</code> function that will use <code>fmt.Println</code> to print the results of binding the data structure to the XML document. <code>Unmarshal</code> could return an error, but we&rsquo;ll ignore it in this case.</p>

<pre><code class="go">package main

import (
    "encoding/xml"
    "fmt"
)

var personXML = []byte(`
&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;`)

type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}

func main() {
    var luann Person
    xml.Unmarshal(personXML, &amp;luann)
    fmt.Println(luann)
}
</code></pre>

<p>I&rsquo;ve posted this code as <a href="https://gist.github.com/larryprice/204fec2e8d33979f8cac">a gist</a> in <a href="https://play.golang.org/p/qiSoxxb5tp">the go playground</a> so you can see it in action.</p>
]]></content>
  </entry>
  
</feed>
