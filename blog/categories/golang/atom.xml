<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Larry Price]]></title>
  <link href="https://larry-price.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://larry-price.com/"/>
  <updated>2017-09-14T21:44:10-05:00</updated>
  <id>https://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    <email><![CDATA[larry@larry-price.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing Go/QML Convergent Ubuntu Apps]]></title>
    <link href="https://larry-price.com/blog/2016/07/07/writing-a-go-slash-qml-convergent-ubuntu-app/"/>
    <updated>2016-07-07T16:31:23-04:00</updated>
    <id>https://larry-price.com/blog/2016/07/07/writing-a-go-slash-qml-convergent-ubuntu-app</id>
    <content type="html"><![CDATA[<p>Thinking about writing an Ubuntu application that will work in Unity 8? You&rsquo;ll be writing a &ldquo;convergent&rdquo; app, which is an application that can respond to touch or mouse, and will adapt appropriately to a phone, tablet, or desktop screen. It will even be able to update its display on-the-fly if, say, you plug your phone into a monitor or bluetooth keyboard.</p>

<p>There are <em>lots</em> of ways to write a convergent application with the <a href="https://developer.ubuntu.com/en/phone/platform/sdk/">Ubuntu SDK</a>. You can build apps in pure QML, C++ with QML, QtQuick, pure HTML5/Javascript, or even <strong>Golang with QML</strong>. We&rsquo;ll be focusing on go apps for the rest of this post.</p>

<p>Go is a young language, and the recent release of <a href="https://blog.golang.org/go1.6">go 1.6</a> has introduced some nasty changes particularly involving cgo. It has also introduced vendoring by default, which is a welcome change.</p>

<p>I&rsquo;m using go 1.6.2. For me, the current project template provided by the Ubuntu SDK feels quite broken. I can&rsquo;t get things to build locally, and furthermore I see no options for pushing an ARM build to my device.</p>

<p>Fortunately, I found this <a href="https://github.com/nikwen/ubuntu-go-qml-template">ubuntu-go-qml-template</a> which is a template to enable running/building a go/qml application locally while also supporting building/installing onto an arm device. The kicker? This tool was designed to work for go 1.3.3. Sigh! Since I&rsquo;m unwilling to compromise and use old technology, I <a href="https://github.com/larryprice/ubuntu-go-qml-template">forked the project</a> and updated it to fit my more modern needs.</p>

<p>Because our go template will depend on QML, we depend on the <a href="https://github.com/go-qml/qml">go-qml</a> project to create the necessary C bindings to allow us to use QML. However, with the update to go 1.6, the current version (revision 2ee7e5f) of go-qml will give a runtime error from cgo with the wonderfully helpful <code>panic: runtime error: cgo argument has Go pointer to Go pointer</code>. Another thorn in our side. Fortunately, this issue is in previously tread-upon ground and there is a <a href="https://github.com/sjb/qml/tree/go1.6-port">fork of go-qml</a> with enough of the cgo issues fixed to run our application with no problems. In the <code>ubuntu-go-qml-template</code> I forked above, I&rsquo;ve gone ahead and vendored this fork of <code>go-qml</code>. It all works because of the default vendoring available in go 1.6.</p>

<p>With that background out of the way, let&rsquo;s run through getting a project started:</p>

<pre><code class="bash">$ sudo apt-get install golang g++ qtdeclarative5-dev qtbase5-private-dev \
                       qtdeclarative5-private-dev libqt5opengl5-dev \
                                             qtdeclarative5-qtquick2-plugin
# installing dependencies...
$ git clone https://github.com/larryprice/ubuntu-go-qml-template.git your-project-name
# cloning repo...
$ cd your-project-name
$ chroot-scripts/setup-chroot.sh
# building a chroot for ubuntu-sdk-15.04
# distro=vivid, arch=arm
# with go 1.6.2 with armhf compilation support
</code></pre>

<p>You may need to have other dependencies including <code>click</code> or <code>phablet-tools</code>. The above commands installed dependencies, cloned the repo, and built and/or updated a chroot for building our source for arm.</p>

<p>Next you&rsquo;ll want to setup the project for your own needs. The original template creator included a nifty <code>setup</code> script to get this done:</p>

<pre><code class="bash">$ ruby setup.rb -v -n your-project-name -a "Your Name" -e "your.email@example.com" \
                   -d "your-developer-namespace"
</code></pre>

<p>This will do some fancy gsub and file renaming to make the template your own.</p>

<p>If you check <code>src/</code>, you&rsquo;ll find a <code>main.go</code> file ready for your use. You&rsquo;ll also find a <code>main.qml</code> file in <code>share/qml/</code>. You can vendor all of your dependencies in <code>vendor/</code>, where you&rsquo;ll already find the <code>qml</code> package.</p>

<p>As far as getting your application to work, there are more scripts available:</p>

<pre><code>$ ./build.sh
# this will build your project locally
$ ./run.sh
# this will build your project locally and then run it on the desktop
</code></pre>

<p>The best part about this template is the ability to build for arm and load your applications onto a device:</p>

<pre><code>$ ./build-in-chroot.sh
# builds the package using the vivid+armhf chroot we set up previously
$ ./install-on-device.sh
# builds for vivid+armhf and installs the click directly on
# the first USB-connected Ubuntu Touch device
</code></pre>

<p>Now you can run and install go/qml applications on desktop or on devices. Time to go build something cool!</p>

<p><em>Disclaimer: In the future, this template will likely need to be updated for new go versions or new default versions of the Ubuntu SDK. Don&rsquo;t be afraid to make a comment below or submit a PR.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go for Web Development 50% Off Sale]]></title>
    <link href="https://larry-price.com/blog/2016/01/21/go-for-web-development-50-percent-off-sale/"/>
    <updated>2016-01-21T10:51:22-05:00</updated>
    <id>https://larry-price.com/blog/2016/01/21/go-for-web-development-50-percent-off-sale</id>
    <content type="html"><![CDATA[<p>At the end of 2015, I published a video course on getting started with web development in Go. For the next two weeks, you can get it for 50% off using this link: <a href="http://bit.ly/1PEubnd">http://bit.ly/1PEubnd</a>. With over 2 hours of content for just over $20, it&rsquo;s a great deal. The sale runs from 21 Jan until 4 Feb 2016.</p>

<p><a href="http://bit.ly/1PEubnd"><img src="https://i.imgur.com/tTPQj2b.png" /></a></p>

<p>The video takes the student through every step of creating a personal library web application from scratch, covering concepts such as routing, database access, and authentication. It&rsquo;s a great introduction to go, and an excellent primer to starting your own go-based web project.</p>

<p>All this comes with the added benefit of supporting me: your local developer. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go for Web Development]]></title>
    <link href="https://larry-price.com/blog/2015/12/30/go-for-web-development/"/>
    <updated>2015-12-30T14:54:11-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/30/go-for-web-development</id>
    <content type="html"><![CDATA[<p>I have published a video series on building web applications in Go called <em><a href="https://www.packtpub.com/web-development/go-web-development-video">Go for Web Development</a></em>.</p>

<p>These videos will guide you through the entire process of creating a web application in Go, all the way from spinning up a basic web server to multi-user authentication. In the end, you&rsquo;ll learn how to vendor dependencies and deploy the application to heroku. Throughout the course, you&rsquo;ll learn to utilize many of the most popular go packages including gorilla/mux, negroni, gorp, ace, and bcrypt. You&rsquo;ll learn about making asynchronous requests from the browser back to the web server, and you&rsquo;ll learn to access external REST APIs from your web server. You&rsquo;ll use go&rsquo;s struct tags to parse both XML and JSON, and you&rsquo;ll use struct tags to access database entities with gorp.</p>

<p>I spent many late nights creating this course, and I&rsquo;ve learned a lot of lessons about creating screencasts along the way. I was also able to solidify much of my base understanding of the go language and learn about many features I don&rsquo;t often utilize. The videos are published by Packt Publishing, and they were a great help along the way. The most valuable lesson I learned from doing these screencasts is that a quality microphone makes a huge difference, and I would have saved myself a lot of trouble had I used my Rock Band microphone from the beginning. In the end everything turned out great. I&rsquo;m relieved to be finished and excited to have an official ISBN connected to my name.</p>

<p><s>The video is currently only $5 for the holidays, but</s> the regular retail price is set to $75 (which is still a bargain considering all the content).</p>

<p>Link: <a href="https://www.packtpub.com/web-development/go-web-development-video">https://www.packtpub.com/web-development/go-web-development-video</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML Parsing in Go]]></title>
    <link href="https://larry-price.com/blog/2015/12/04/xml-parsing-in-go/"/>
    <updated>2015-12-04T15:30:14-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/04/xml-parsing-in-go</id>
    <content type="html"><![CDATA[<p>Need to parse an XML file in go? XML (en|de)coding is build into go&rsquo;s standard library. Basic parsing of nodes and embedded nodes is straightforward, but there are some interesting things to think about when you need to parse attributes, lists, and if you don&rsquo;t want to create new structs all over the place.</p>

<p>For this exercise, let&rsquo;s look at the following XML document:</p>

<pre><code class="xml">&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;
</code></pre>

<h3>Defining a Data Structure</h3>

<p>The simplest node to parse is going to be <code>&lt;name&gt;</code>. We&rsquo;ll need an object to unmarshal the XML into, which we&rsquo;ll call <code>Person</code>. Every field on <code>Person</code> will be evaluated by the XML encoder to be populated based on the field&rsquo;s name. However, our struct field names and node names don&rsquo;t usually correspond that simply. Because of this, we&rsquo;ll use <code>xml</code> struct tags to identify how to map each node to a go field. Here&rsquo;s an example for <code>&lt;name&gt;</code>:</p>

<pre><code class="go">type Person struct {
  Name string `xml:"name"`
}
</code></pre>

<p>The next node contains a list of <code>&lt;address&gt;</code> nodes. For an address node, we&rsquo;ll have to create a similar struct with <code>City</code> and <code>Street</code> fields:</p>

<pre><code>type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
}
</code></pre>

<p>While parsing each <code>Address</code>, we also want to find the <code>type</code> of address, which can be found as an attribute on the <code>&lt;address&gt;</code> node. By adding <code>attr</code> to our XML struct tag, we can properly parse the <code>type</code> field as well:</p>

<pre><code class="go">type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
    Type string   `xml:"type,attr"`
}
</code></pre>

<p>A <code>Person</code> has a list of <code>Address</code>es. Since we know that <code>address</code> is a direct descendant, we can use the <code>&gt;</code> keyword to parse each <code>&lt;address&gt;</code> from <code>&lt;addresses&gt;</code> into an embedded struct on our <code>Person</code> struct.</p>

<pre><code class="go">type Person struct {
    Name string         `xml:"name"`
    Addresses []Address `xml:"addresses&gt;address"`
}
</code></pre>

<p>This code will work to parse the original document, but do we really need to define a formal struct for addresses? If there was only one address, we could put all the fields directly on the <code>Person</code> struct. However, since we&rsquo;re dealing with a list, our best option is to use an anonymous struct:</p>

<pre><code class="go">type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}
</code></pre>

<h3>Binding the Data Structure</h3>

<p>We can use the <a href="https://golang.org/pkg/encoding/xml/">encoding/xml</a> package to decode the given XML. Given that our raw XML document is stored in a <code>[]byte</code> called <code>document</code>, we&rsquo;ll use <code>xml.Unmarshal</code> to bind our data structure to the XML document:</p>

<pre><code class="go">var luann Person
xml.Unmarshal(document, &amp;luann)
</code></pre>

<h3>Final Code</h3>

<p>Let&rsquo;s put it all together, including a <code>main</code> function that will use <code>fmt.Println</code> to print the results of binding the data structure to the XML document. <code>Unmarshal</code> could return an error, but we&rsquo;ll ignore it in this case.</p>

<pre><code class="go">package main

import (
    "encoding/xml"
    "fmt"
)

var personXML = []byte(`
&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;`)

type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}

func main() {
    var luann Person
    xml.Unmarshal(personXML, &amp;luann)
    fmt.Println(luann)
}
</code></pre>

<p>I&rsquo;ve posted this code as <a href="https://gist.github.com/larryprice/204fec2e8d33979f8cac">a gist</a> in <a href="https://play.golang.org/p/qiSoxxb5tp">the go playground</a> so you can see it in action.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture for a Golang Web App]]></title>
    <link href="https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app/"/>
    <updated>2015-06-25T07:24:27-04:00</updated>
    <id>https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app</id>
    <content type="html"><![CDATA[<p>Setting up a web application in Golang can be a daunting task. If you&rsquo;re used to rails, you probably miss having your hand held at this point. I&rsquo;m using this architecture on <a href="https://www.refer-madness.com">Refer Madness</a> [<a href="https://github.com/larryprice/refermadness">source</a>]. Here&rsquo;s my directory structure:</p>

<pre><code>-public/
-views/
-models/
-utils/
-controllers/
-web/
-main.go
</code></pre>

<p>I&rsquo;ll break this down architecturally. At each directory level, files are only allowed to access code from directories at the same or a higher level. This means that <code>utils</code> can access itself and <code>models</code>; <code>web</code> can access itself, <code>controllers</code>, <code>utils</code>, and <code>models</code>; and <code>models</code> can only access itself. I do this to keep a thick line between all the layers and to avoid recursive dependencies. Let&rsquo;s talk about each level individually!</p>

<h4>main.go</h4>

<p><code>main.go</code> is my main file in charge of creating dependencies, discovering environment variables, and starting the web server. Here&rsquo;s a sample:</p>

<pre><code class="go main.go">package main

import (
  "github.com/larryprice/refermadness/utils"
  "github.com/larryprice/refermadness/web"
  "github.com/stretchr/graceful"
  "os"
)

func main() {
  isDevelopment := os.Getenv("ENVIRONMENT") == "development"
  dbURL := os.Getenv("MONGOLAB_URI")
  if isDevelopment {
    dbURL = os.Getenv("DB_PORT_27017_TCP_ADDR")
  }

  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv("DATABASE_NAME"), 0)
  cuAccessor := utils.NewCurrentUserAccessor(1)
  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv("GOOGLE_OAUTH2_CLIENT_ID"),
    os.Getenv("GOOGLE_OAUTH2_CLIENT_SECRET"), os.Getenv("SESSION_SECRET"),
    isDevelopment, os.Getenv("GOOGLE_ANALYTICS_KEY"))

  port := os.Getenv("PORT")
  if port == "" {
    port = "3000"
  }

  graceful.Run(":"+port, 0, s)
}
</code></pre>

<p>Since <code>main.go</code> is on the lowest level, it has access to every other directory: in this case, <code>utils</code> and <code>web</code>. I grab all the environment variables and inject them where necessary. I create the server, injecting dependencies, and then start it on the port I want.</p>

<h4>web</h4>

<p>I keep my server code in the <code>web</code> directory, which includes some web middleware. Here&rsquo;s the internal structure of the <code>web</code> directory:</p>

<pre><code>-web/
|-middleware/
|-server.go
</code></pre>

<p><code>server.go</code> contains the definition of my web server. The web server creates all my web controllers and adds middleware to my negroni server. Here&rsquo;s an excerpt:</p>

<pre><code class="go web/server.go">package web

import (
  "github.com/codegangsta/negroni"
  "github.com/goincremental/negroni-sessions"
  "github.com/goincremental/negroni-sessions/cookiestore"
  "github.com/gorilla/mux"
  "github.com/larryprice/refermadness/controllers"
  "github.com/larryprice/refermadness/utils"
  "github.com/larryprice/refermadness/web/middleware"
  "github.com/unrolled/secure"
  "gopkg.in/unrolled/render.v1"
  "html/template"
  "net/http"
)

type Server struct {
  *negroni.Negroni
}

func NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,
  sessionSecret string, isDevelopment bool, gaKey string) *Server {
  s := Server{negroni.Classic()}
  session := utils.NewSessionManager()
  basePage := utils.NewBasePageCreator(cua, gaKey)
  renderer := render.New()

  router := mux.NewRouter()

  // ...

  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)
  accountController.Register(router)

  // ...

  s.Use(sessions.Sessions("refermadness", cookiestore.New([]byte(sessionSecret))))
  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())
  s.UseHandler(router)
  return &amp;s
}
</code></pre>

<p>A <code>server</code> struct is a <code>negroni.Negroni</code> web server. I create some dependencies from <code>utils</code> and external packages, create a router, create controllers with the dependencies, and register the router with my controllers. I also add in any middleware I may need. Speaking of middleware, here&rsquo;s an example:</p>

<pre><code class="go web/middleware/database.go">package middleware

import (
  "github.com/codegangsta/negroni"
  "github.com/larryprice/refermadness/utils"
  "net/http"
)

type Database struct {
  da utils.DatabaseAccessor
}

func NewDatabase(da utils.DatabaseAccessor) *Database {
  return &amp;Database{da}
}

func (d *Database) Middleware() negroni.HandlerFunc {
  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
    reqSession := d.da.Clone()
    defer reqSession.Close()
    d.da.Set(r, reqSession)
    next(rw, r)
  }
}
</code></pre>

<p>This is a standard middleware definition for accessing a database session from an HTTP route. The base of this file was taken from <a href="http://modocache.svbtle.com/restful-go">Brian Gesiak&rsquo;s blog post on RESTful Go</a> and was modifiedto fit my needs.</p>

<h4>controllers/</h4>

<p>A controller is similar to the controller concept found in Rails. A controller registers its own route with the router provided and then sets up function calls. An abbreviated example:</p>

<pre><code class="go controllers/service_controller.go">package controllers

import (
  "encoding/json"
  "errors"
  "github.com/gorilla/mux"
  "github.com/larryprice/refermadness/models"
  "github.com/larryprice/refermadness/utils"
  "gopkg.in/mgo.v2/bson"
  "gopkg.in/unrolled/render.v1"
  "html/template"
  "net/http"
  "strings"
)

type ServiceControllerImpl struct {
  currentUser utils.CurrentUserAccessor
  basePage    utils.BasePageCreator
  renderer    *render.Render
  database    utils.DatabaseAccessor
}

func NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,
  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {
  return &amp;ServiceControllerImpl{
    currentUser: currentUser,
    basePage:    basePage,
    renderer:    renderer,
    database:    database,
  }
}

func (sc *ServiceControllerImpl) Register(router *mux.Router) {
  router.HandleFunc("/service/{id}", sc.single)
  // ...
}

// ...

type serviceResult struct {
  *models.Service
  RandomCode *models.ReferralCode
  UserCode   *models.ReferralCode
}

type servicePage struct {
  utils.BasePage
  ResultString string
}

func (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {
  data, err := sc.get(w, r)

  if len(r.Header["Content-Type"]) == 1 &amp;&amp; strings.Contains(r.Header["Content-Type"][0], "application/json") {
    if err != nil {
      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{
        "error": err.Error(),
      })
      return
    }
    sc.renderer.JSON(w, http.StatusOK, data)
    return
  } else if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
  }

  resultString, _ := json.Marshal(data)
  t, _ := template.ParseFiles("views/layout.html", "views/service.html")
  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})
}

// ...
</code></pre>

<h4>utils/</h4>

<p>Files that belong in the <code>utils</code> directory provide small levels of functionality to support the rest of the codebase. In my case, I have structs which access the request context, manipulate the session, and define a base page for specific pages to inherit. Here&rsquo;s where I access the context to set the user:</p>

<pre><code class="go utils/current_user_accessor.go">package utils

import (
  "github.com/gorilla/context"
  "github.com/larryprice/refermadness/models"
  "net/http"
)

type CurrentUserAccessor struct {
  key int
}

func NewCurrentUserAccessor(key int) *CurrentUserAccessor {
  return &amp;CurrentUserAccessor{key}
}

func (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {
  context.Set(r, cua.key, user)
}

func (cua *CurrentUserAccessor) Clear(r *http.Request) {
  context.Delete(r, cua.key)
}

func (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {
  if rv := context.Get(r, cua.key); rv != nil {
    return rv.(*models.User)
  }
  return nil
}
</code></pre>

<h4>models/</h4>

<p>Models are data structures for representing my database concepts. I use my models to access the database - I create an empty model and then populate it with a database query. Here&rsquo;s an example of a model I use:</p>

<pre><code class="go models/service.go">package models

import (
  "gopkg.in/mgo.v2"
  "gopkg.in/mgo.v2/bson"
  "strings"
  "time"
)

type Service struct {
  // identification information
  ID          bson.ObjectId `bson:"_id"`
  Name        string        `bson:"name"`
  Description string        `bson:"description"`
  URL         string        `bson:"url"`
  Search      string        `bson:"search"`
}

func NewService(name, description, url string, creatorID bson.ObjectId) *Service {
  url = strings.TrimPrefix(strings.TrimPrefix(url, "http://"), "https://")
  return &amp;Service{
    ID:            bson.NewObjectId(),
    Name:          name,
    URL:           url,
    Description:   description,
    Search:        strings.ToLower(name) + ";" + strings.ToLower(description) + ";" + strings.ToLower(url),
  }
}

func (s *Service) Save(db *mgo.Database) error {
  _, err := s.coll(db).UpsertId(s.ID, s)
  return err
}

func (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {
  return s.coll(db).FindId(id).One(s)
}

func (*Service) coll(db *mgo.Database) *mgo.Collection {
  return db.C("service")
}

type Services []Service

func (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {
  return s.coll(db).Find(bson.M{"_id": bson.M{"$in": ids}}).Sort("name").All(s)
}

func (*Services) coll(db *mgo.Database) *mgo.Collection {
  return db.C("service")
}

// ...
</code></pre>

<h4>views/</h4>

<p>I keep my goalng templates in the <code>views</code> directory. Pretty basic - whatever templating engine I use, I throw it into this <code>views</code> directory.</p>

<h4>public/</h4>

<p>As usual, this directory is all my public files - <code>css</code>, <code>img</code>, <code>scripts</code>.</p>

<h3>That&rsquo;s cool - how do I run this?</h3>

<p>It&rsquo;s no secret that I like <a href="https://www.docker.com/">docker</a>, so that&rsquo;s my preferred method of running this application. If I wanted to run this without docker, I would throw the root of this directory into <code>$GOPATH/src/github.com/larryprice/refermadness</code>. Running <code>go get</code> will fetch all the missing dependencies and running <code>go run main.go</code> or <code>go build; ./refermadness</code> should run the file. If you do want to use docker (and you know I do), I start with a <code>Dockerfile</code>:</p>

<pre><code class="docker Dockerfile">FROM golang:1.4

RUN go get github.com/codegangsta/gin

ADD . /go/src/github.com/larryprice/refermadness
WORKDIR /go/src/github.com/larryprice/refermadness
RUN go get
</code></pre>

<p>And, since I also love <a href="https://github.com/docker/compose">compose</a>, I run everything with a compose file. I use a JSC transformer, a SASS transpiler, and a mongo database, so my <code>docker-compose.yml</code> file looks like:</p>

<pre><code class="yml docker-compose.yml">main:
  build: .
  command: gin run
  env_file: .env
  volumes:
    - ./:/go/src/github.com/larryprice/refermadness
  working_dir: /go/src/github.com/larryprice/refermadness
  ports:
    - "3000:3000"
  links:
    - db
sass:
  image: larryprice/sass
  volumes: 
    - ./public/css:/src
jsx:
  image: larryprice/jsx
  volumes: 
    - ./public/scripts:/src
db:
  image: mongo:3.0
  command: mongod --smallfiles --quiet --logpath=/dev/null
  volumes_from:
    - dbvolume
dbvolume:
  image: busybox:ubuntu-14.04
  volumes:
    - /data/db
</code></pre>

<p>And then run <code>docker-compose up</code> to run all the containers and start up the server.</p>

<p>&hellip;And that&rsquo;s that! I like setting my code up this way as a compromise between idiomatic Go and ruby on rails. I inject parameters whrever possible to keep things testable. I keep my concerns separated as much as possible. Go is fast and the syntax is clean, but there aren&rsquo;t enough examples of creating full-blown web applications available. At this point, we don&rsquo;t know the future of Go, but I anticipate it becoming big. Hopefully this architecture overview can help someone get started making the transition from a more traditional MVC framework to golang.</p>
]]></content>
  </entry>
  
</feed>
