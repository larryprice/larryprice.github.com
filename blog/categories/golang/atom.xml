<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-05-25T16:37:45-04:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Better testing in Go with gocheck]]></title>
    <link href="http://larry-price.com/blog/2014/05/13/better-testing-in-go-with-gocheck/"/>
    <updated>2014-05-13T21:14:39-04:00</updated>
    <id>http://larry-price.com/blog/2014/05/13/better-testing-in-go-with-gocheck</id>
    <content type="html"><![CDATA[<p>As a quick reminder, <a href="//golang.org/">golang</a> is a really fun programming language to use. It even includes <a href="//golang.org/doc/code.html#Testing">testing out of the box</a>! Unfortunately, this out-of-the-box testing framework isn&rsquo;t all that great. It lacks the syntactic sugar of mature frameworks like <a href="//rspec.info">rspec</a> or <a href="//code.google.com/p/googletest/">gtest</a>.</p>

<p>Of course, there are alternatives. I found an open-source library (licensed with Simplified BSD) called <a href="//labix.org/gocheck">gocheck</a>.</p>

<p>Gocheck, how do I love thee? Let me count the ways:</p>

<ul>
<li>Test fixtures</li>
<li>Improved assertions</li>
<li>Improved test output</li>
<li>Sugar-coated syntax</li>
<li>Test skipping</li>
<li>Oh my</li>
</ul>


<p>As usual, it&rsquo;s time to guide you through a contrived example. Start by installing the package:</p>

<p><code>bash
$ go get gopkg.in/check.v1
</code></p>

<p>Let&rsquo;s see, what should we make&hellip; how about a tip calculating library? We should start by testing, because we&rsquo;re obsessed with TDD.</p>

<p>Test #1: Returns 0 for free meal</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{}</p>

<p>var _ = Suite(&amp;MySuite{})</p>

<p>func (s <em>MySuite) TestReturns0ForFreeMeal(c </em>C) {
  c.Assert(calculateTip(0.0), Equals, 0.0)
}
```</p>

<p>Not quite as obvious as the internal testing framework. First we hook up gocheck into the &ldquo;go test&rdquo; runner. Then we create a test suite; ours is empty for now and called <code>MySuite</code>. We call <code>Suite</code> to intialize the test runner with our custom suite. We then write our first test to assert that calculating the tip returns a value equal to 0. All tests must be prefixed with the word &ldquo;Test&rdquo;. Now I&rsquo;ll write the implementation:</p>

<p>``` go calculator.go
package cheapskate</p>

<p>func calculateTip(bill float64) float64 {
  return 0.0
}
```</p>

<p>Running the tests&hellip;</p>

<p><code>bash
$ go test
OK: 1 passed
PASS
ok    _/home/lrp/Projects/2014/gocheck-quick  0.003s
</code></p>

<p>Woohoo! All passed. What happens if we write a failing test?</p>

<p><code>go calculator_test.go
...
func (s *MySuite) TestReturns15PercentByDefault(c *C) {
  c.Assert(calculateTip(100.0), Equals, 15.0)
}
</code></p>

<p>Results:</p>

<p>``` bash
lrp@cilantro:~/Projects/2014/gocheck-quick$ go test</p>

<hr />

<p>FAIL: calculator_test.go:19: MySuite.TestReturns15PercentByDefault</p>

<p>calculator_test.go:20:</p>

<pre><code>c.Assert(calculateTip(100.0), Equals, 15.0)
</code></pre>

<p>&hellip; obtained float64 = 0
&hellip; expected float64 = 15</p>

<p>OOPS: 1 passed, 1 FAILED
&mdash;&ndash; FAIL: Test (0.00 seconds)
FAIL
exit status 1
FAIL  _/home/lrp/Projects/2014/gocheck-quick  0.003s
```</p>

<p>A nasty failure that one. I&rsquo;ll fix it and continue:</p>

<p>``` go calculator.go
package cheapskate</p>

<p>func calculateTip(bill float64) float64 {
  return .15 * bill
}
```</p>

<p>I want to create a Setup method for my entire suite. I&rsquo;ll store some silly information there for information&rsquo;s sake. The minBill and maxBill variables will only be set when I first load the suite.</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{
  minBill float64
  maxBill float64
}</p>

<p>func (s <em>MySuite) SetUpSuite(c </em>C) {
  s.minBill = 0
  s.maxBill = 100
}</p>

<p>var _ = Suite(&amp;MySuite{})</p>

<p>func (s <em>MySuite) TestReturns0ForFreeMeal(c </em>C) {
  c.Assert(calculateTip(s.minBill), Equals, 0.0)
}</p>

<p>func (s <em>MySuite) TestReturns15PercentByDefault(c </em>C) {
  c.Assert(calculateTip(s.maxBill), Equals, 15.0)
}
```</p>

<p>What if I wanted to set some information at the start of each test? I&rsquo;ll log the current test number on the suite, updating it every time I run a test:</p>

<p>``` go calculator_test.go
package cheapskate</p>

<p>import (
  &ldquo;testing&rdquo;
  . &ldquo;gopkg.in/check.v1&rdquo;</p>

<p>  &ldquo;fmt&rdquo;
)</p>

<p>// Hook up gocheck into the &ldquo;go test&rdquo; runner.
func Test(t *testing.T) { TestingT(t) }</p>

<p>type MySuite struct{
  testNumber int
}</p>

<p>func (s <em>MySuite) SetUpTest(c </em>C) {
  fmt.Println(s.testNumber)
  s.testNumber += 1
}
&hellip;
```</p>

<p>Result:</p>

<p><code>bash
$ go test
0
1
OK: 2 passed
PASS
ok    _/home/lrp/Projects/2014/gocheck-quick  0.004s
</code></p>

<p>You can create tear down methods for suites and tests in the same manner, replacing the appropriate words above.</p>

<p>There&rsquo;s loads of other cool stuff gocheck can do, I&rsquo;ve barely scratched the surface with what little experience I&rsquo;ve had using it. Like any testing framework, I&rsquo;m sure it has its advantages and disadvantages, but it sure beats the pants off the off-the-shelf framework Google includes with golang.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finishing the Google Go Writing Web Applications Tutorial]]></title>
    <link href="http://larry-price.com/blog/2014/01/07/finishing-the-google-go-writing-web-applications-tutorial/"/>
    <updated>2014-01-07T22:45:03-05:00</updated>
    <id>http://larry-price.com/blog/2014/01/07/finishing-the-google-go-writing-web-applications-tutorial</id>
    <content type="html"><![CDATA[<h3>A golang web app tutorial</h3>

<p>I did some work with <a href="http://golang.org/">Google Go</a> recently and had the chance to follow their great tutorial <em><a href="http://golang.org/doc/articles/wiki/">Writing Web Applications</a></em>. The tutorial is pretty simple: use the Go http library to create a very simple wiki-style site. I like this tutorial a lot because there&rsquo;s not too much hand-holding, but they do eventually hand you the <a href="http://golang.org/doc/articles/wiki/final.go">final code listing</a>. Then the good people at Google give you the tall task of completing the following &lsquo;Other tasks&rsquo; without solutions:</p>

<ul>
<li>Store templates in tmpl/ and page data in data/.</li>
<li>Add a handler to make the web root redirect to /view/FrontPage.</li>
<li>Spruce up the page templates by making them valid HTML and adding some CSS rules.</li>
<li>Implement inter-page linking by converting instances of [PageName] to
&lt;a href=&ldquo;<a href="http://larry-price.com/view/PageName">http://larry-price.com/view/PageName</a>&rdquo;>PageName&lt;/a>. (hint: you could use regexp.ReplaceAllFunc to do this)</li>
</ul>


<p>This is what I&rsquo;d like to go over. I scoured the web and didn&rsquo;t have much luck finding solutions to these issues. That would be okay if they were all trivial, but the final step is not straightforward. I&rsquo;m going to assume you&rsquo;ve already gone over the tutorial. You can see <a href="https://github.com/larryprice/gowiki/">my repository on Github</a>, and I have included links to the appropriate commits in the code sections of this blog post.</p>

<h4>Store templates in tmpl/ and page data in data/</h4>

<p>The tutorial originally has the developer store all pages in the project directory. Every time a user made a new wiki page, a new file would creep into the project directory. All HTML templates were also stored in the project directory.</p>

<p>Moving templates is quite trivial. In the global scope:</p>

<p><code>diff wiki.go https://github.com/larryprice/gowiki/commit/9994d11b5275bc5faee911e5db2c994bc91052e2
-var templates = template.Must(template.ParseFiles("edit.html", "view.html"))
+var templates = template.Must(template.ParseFiles("tmpl/edit.html", "tmpl/view.html"))
</code></p>

<p>I found moving the page data to <code>data/</code> was a little trickier, especially if the directory didn&rsquo;t already exist. You may not have the same issue, but I remedied this by creating the directory if it doesn&rsquo;t exist. My <code>save</code> function differences:</p>

<p><code>diff wiki.go https://github.com/larryprice/gowiki/commit/e86a707d37b802b2d59b8ef261b3fdcab46d5870
func (p *Page) save() error {
-    filename := p.Title + ".txt"
-    return ioutil.WriteFile(filename, p.Body, 0600)
+  os.Mkdir("data", 0777)
+  filename := "data/" + p.Title + ".txt"
+  return ioutil.WriteFile(filename, p.Body, 0600)
}
</code></p>

<h4>Add a handler to make the web root redirect to /view/FrontPage</h4>

<p>All we&rsquo;re going to do is create a simple handler called <code>rootHandler</code> that redirects to a new page called <code>FrontPage</code>. We then add it in the <code>main</code> function. The tutorial had us wrap out handlers in a function call to take some special actions, but that wrapper would mess up our handler in its current form. So I just <code>Redirect</code> to the <code>view</code> handler, which will then decide whether to view or create the FrontPage.</p>

<p>``` diff wiki.go <a href="https://github.com/larryprice/gowiki/commit/e41fccc2d244a3b0d62d600d94897a076c87d53d">https://github.com/larryprice/gowiki/commit/e41fccc2d244a3b0d62d600d94897a076c87d53d</a>
+ func rootHandler(w http.ResponseWriter, r *http.Request) {
+   http.Redirect(w, r, &ldquo;/view/FrontPage&rdquo;, http.StatusFound)
+ }</p>

<p>&hellip;</p>

<p>func main() {
+  http.HandleFunc(&ldquo;/&rdquo;, rootHandler)
  http.HandleFunc(&ldquo;/view/&rdquo;, makeHandler(viewHandler))
  http.HandleFunc(&ldquo;/edit/&rdquo;, makeHandler(editHandler))
  http.HandleFunc(&ldquo;/save/&rdquo;, makeHandler(saveHandler))
```</p>

<h4>Spruce up the page templates by making them valid HTML and adding some CSS rules.</h4>

<p>I took my old <code>.html</code> files and put them through <a href="http://validator.w3.org/#validate_by_input">a validator</a>. Making them valid only involved adding <code>DOCTYPE</code>, <code>html</code>, and <code>head</code> tags. The <code>head</code> tag needed <code>meta</code>, and <code>title</code> tags and we were valid. I&rsquo;ve shown <code>view.html</code> below.</p>

<p>``` diff view.html <a href="https://github.com/larryprice/gowiki/commit/771b4ecc8a550ee438720dc5c3d3f47954a1e4ff">https://github.com/larryprice/gowiki/commit/771b4ecc8a550ee438720dc5c3d3f47954a1e4ff</a>
+&lt;!DOCTYPE html>
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>Wiki made using Golang</title>
+</head>
 <h1></h1></p>

<p> <p>[<a href="http://larry-price.com/edit/">edit</a>]</p></p>

<p> <div></div>
+</html>
```</p>

<h4>Implement inter-page linking by converting instances of [PageName]</h4>

<p>Converting [PageName] to a hyperlink was a bit more complicated than expected. I originally just tried to run the string through <code>ReplaceAllFunc</code> and replace all instance of [PageName] with an equivalent hyperlink. This does not work because we use Go&rsquo;s <code>ExecuteTemplate</code> method to render our template. <code>ExecuteTemplate</code> escapes any HTML that we give it to prevent us from displaying unwanted HTML. Getting around this was the fun part, because I want the benefit of escaped HTML while still having the ability to substitute my own HTML.</p>

<p>As it turns out, <code>ExecuteTemplate</code> will not escape variables of the type <code>template.HTML</code>. So I added another variable onto the <code>Page</code> struct called <code>DisplayBody</code>.</p>

<p>``` diff wiki.go <a href="https://github.com/larryprice/gowiki/commit/38c48717420de78f15dc48152ce16d1bdb417288">https://github.com/larryprice/gowiki/commit/38c48717420de78f15dc48152ce16d1bdb417288</a>
type Page struct {</p>

<pre><code> Title string
 Body  []byte
</code></pre>

<ul>
<li> DisplayBody template.HTML
}
```</li>
</ul>


<p>Next, I create a regular expression to find instances of [PageName] and I put the defintion above the <code>main</code> method.</p>

<p><code>diff wiki.go https://github.com/larryprice/gowiki/commit/38c48717420de78f15dc48152ce16d1bdb417288
+var linkRegexp = regexp.MustCompile("\\[([a-zA-Z0-9]+)\\]")
</code></p>

<p>In my <code>viewHandler</code>, I escape <code>Body</code> and then set <code>DisplayBody</code> to that escaped string with the links substituted.</p>

<p><code>diff wiki.go https://github.com/larryprice/gowiki/commit/38c48717420de78f15dc48152ce16d1bdb417288
+  escapedBody := []byte(template.HTMLEscapeString(string(p.Body)))
+
+  p.DisplayBody = template.HTML(linkRegexp.ReplaceAllFunc(escapedBody, func(str []byte) []byte {
+      matched := linkRegexp.FindStringSubmatch(string(str))
+      out := []byte("&lt;a href=\"/view/"+matched[1]+"\"&gt;"+matched[1]+"&lt;/a&gt;")
+      return out
+    }))
  renderTemplate(w, "view", p)
}
</code></p>

<p>To finish up, I modify the <code>view.html</code> to show <code>DisplayBody</code>. I don&rsquo;t use <code>printf</code>, because that would turn <code>DisplayBody</code> back into a <code>string</code> and <code>ExecuteTemplate</code> would escape it.</p>

<p><code>diff wiki.go https://github.com/larryprice/gowiki/commit/38c48717420de78f15dc48152ce16d1bdb417288
-&lt;div&gt;&lt;/div&gt;
+&lt;div&gt;&lt;/div&gt;
</code></p>

<p>And that completes the extra exercises for Google&rsquo;s <em>Writing Web Applications</em> tutorial. Hopefully one day this helps someone who gets stuck.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up a Go environment in Ubuntu]]></title>
    <link href="http://larry-price.com/blog/2013/12/15/setting-up-a-go-environment-in-ubuntu-12-dot-04/"/>
    <updated>2013-12-15T18:40:00-05:00</updated>
    <id>http://larry-price.com/blog/2013/12/15/setting-up-a-go-environment-in-ubuntu-12-dot-04</id>
    <content type="html"><![CDATA[<p>Some very light cajoling led me to do some investigation into <a href="http://golang.org/">Google Go</a> (often called <strong>golang</strong> for ease of internet search). This is a brief recounting of how I got up and running on <a href="http://ubuntu.com">Ubuntu</a> (first 12.04 and then 13.10). Luckily, this has been made espcially easy for us with the introduction of a <a href="http://packages.ubuntu.com/precise/golang">golang package in the Ubuntu package repositories</a>. There are also <a href="http://golang.org/doc/install">official installation instructions</a> if you don&rsquo;t like mine.</p>

<p>Open up a terminal and let loose:</p>

<p><code>bash
$ sudo apt-get install golang
</code></p>

<p>The download is pretty heavy, so this step may take some time. Eventually the installer for <code>golang-go</code> will ask you if you want to &ldquo;Report installation of public packages to Go Dashboard.&rdquo; I&rsquo;ve been choosing &ldquo;No&rdquo; to this question and have no complaints.</p>

<p>Now comes the fun part. Serious Go development relies on having a &ldquo;workspace&rdquo; setup involving a specific directory structure including <code>bin/</code>, <code>pkg/</code>, and <code>src/</code> directories. Google&rsquo;s <a href="http://golang.org/doc/code.html">official set-up page</a> contains more information about these workspaces.</p>

<p>I&rsquo;m not a big fan of putting a visible directory in <code>$HOME</code>, so I opted to make a hidden directory called <code>.go</code>. After creating the directory, the environment variable <code>$GOPATH</code> needs to be set and <code>$PATH</code> needs to be adjusted.</p>

<p><code>bash
$ mkdir ~/.go
$ echo "GOPATH=$HOME/.go" &gt;&gt; ~/.bashrc
$ echo "export GOPATH" &gt;&gt; ~/.bashrc
$ echo "PATH=\$PATH:\$GOPATH/bin # Add GOPATH/bin to PATH for scripting" &gt;&gt; ~/.bashrc
$ source ~/.bashrc
</code></p>

<p>Now I&rsquo;m going to create a go project and add a link to it in the workspace I just created.</p>

<p><code>bash
$ mkdir -p $GOPATH/src/github.com/user
$ mkdir ~/hello-go
$ ln -s ~/hello-go ~/.go/src/github.com/user/hello-go
</code></p>

<p>For some actual test code, I&rsquo;ll add a file in my <code>hello-go/</code> directory called <code>hello.go</code> with the following code:</p>

<p>``` go hello.go
package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
  fmt.Println(&ldquo;Hello world&rdquo;)
}
```</p>

<p>Now I&rsquo;m going to install the binary created from compiling this code into my <code>$GOPATH</code> to verify that my workspace is set up correctly, then I&rsquo;ll run it to behold the fruit of my efforts.</p>

<p><code>bash
$ go install github.com/user/hello-go
$ hello-go
Hello world
</code></p>

<p>Installing is not necessary every time I want to test that my code compiles; running <code>go build</code> in the source directory will create a local executable that can be executed for incremental testing.</p>

<p>If you&rsquo;re interested in learning golang, I would recommend doing the <a href="http://tour.golang.org/">go tour</a>. It goes way beyond a trivial hello world program and gives you some insight into many coplex go concepts (I even posted <a href="https://gist.github.com/larryprice/7647808">my solutions as a gist</a>, if you&rsquo;re interested).</p>
]]></content>
  </entry>
  
</feed>
