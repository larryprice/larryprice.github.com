<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Larry Price]]></title>
  <link href="https://larry-price.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://larry-price.com/"/>
  <updated>2020-11-03T11:30:15-06:00</updated>
  <id>https://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    <email><![CDATA[larry@larry-price.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick Start to Vendor Go Dependencies with govendor]]></title>
    <link href="https://larry-price.com/blog/2018/04/26/quick-start-to-vendor-go-dependencies-with-govendor/"/>
    <updated>2018-04-26T19:34:04-05:00</updated>
    <id>https://larry-price.com/blog/2018/04/26/quick-start-to-vendor-go-dependencies-with-govendor</id>
    <content type="html"><![CDATA[<p>I recently spent a few days adapting my <a href="https://www.packtpub.com/web-development/go-web-development-video">Go for Web Development video series</a> into a text-based course. In doing so, I had the chance to investigate some of the new vendoring tools available in Go. As of Go 1.5, &ldquo;vendoring&rdquo; dependencies has become the norm. Vendoring means tracking your dependencies and their versions and including those dependencies as part of your project.</p>

<p>In particular, I explored the uses of the <a href="https://github.com/kardianos/govendor">govendor</a> package, mostly because it&rsquo;s supported by default by Heroku. The docs on the GitHub are a lot more thorough than what I&rsquo;ll go over here.</p>

<p><code>govendor</code> is easily installed within the go ecosystem. Assuming that <code>$GOPATH/bin</code> is in your path:</p>

<pre><code class="bash">$ go get -u github.com/kardianos/govendor
$ which govendor
/home/lrp/go/bin/govendor
</code></pre>

<p>Now we just initialize the <code>govendor</code> directory and start installing dependencies. The <code>govendor fetch</code> command is pretty much all you&rsquo;ll need:</p>

<pre><code class="bash">$ govendor init
$ govendor fetch github.com/jinzhu/gorm
$ govendor fetch golang.org/x/crypto/bcrypt
</code></pre>

<p><code>init</code> will create a <code>vendor</code> directory in your project path. Go will check this directory for any packages as though they were in your <code>$GOPATH/src</code> directory. The <code>fetch</code> calls will add new packages or update the given package in your <code>vendor</code> directory; in this case, I&rsquo;ve fetched the latest versions of <code>gorm</code> and <code>bcrypt</code>.</p>

<p>This might seem painful, but the thing to do next is to commit everything in the vendor directory to your repository. Now you have it forever! This means that anyone who wants to run this version of your code in the future doesn&rsquo;t have to worry about dependency versions and can instantly run your package with a valid go install.</p>

<p>If you don&rsquo;t want to add all these packages to your repository, I don&rsquo;t blame you. You can get around this by committing just your <code>vendor/vendor.json</code> file and then using <code>govendor sync</code> to install the missing packages after downloading your source code. This should be familiar to anyone who&rsquo;s used <code>bundler</code> in ruby, <code>virtualenv</code> in python, or <code>npm</code> in Node.JS. If you&rsquo;re using git, you&rsquo;ll want a <code>.gitignore</code> with the following:</p>

<pre><code>vendor/*
!vendor/vendor.json
</code></pre>

<p>This will ignore everything in <code>vendor/</code> except for the <code>vendor.json</code> file which lists all your packages and their corresponding versions. Now, to install any packages from <code>vendor.json</code> that you don&rsquo;t already have in your <code>vendor</code> directory:</p>

<pre><code class="bash">$ govendor sync
</code></pre>

<p><code>govendor</code> is a pretty powerful tool for vendoring your go dependencies and getting your application Heroku-ready, and I recommend <a href="https://github.com/kardianos/govendor">checking out the docs</a> for a more advanced overview. There are also many other vendoring options available, including an official go vendoring tool called <a href="https://github.com/golang/dep">dep</a> that works with go 1.9+. <code>dep</code> will most definitely play a big role in refining the ideas that these third-party tools have created and the go ecosystem will become more stable.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Go/QML Convergent Ubuntu Apps]]></title>
    <link href="https://larry-price.com/blog/2016/07/07/writing-a-go-slash-qml-convergent-ubuntu-app/"/>
    <updated>2016-07-07T16:31:23-04:00</updated>
    <id>https://larry-price.com/blog/2016/07/07/writing-a-go-slash-qml-convergent-ubuntu-app</id>
    <content type="html"><![CDATA[<p>Thinking about writing an Ubuntu application that will work in Unity 8? You&rsquo;ll be writing a &ldquo;convergent&rdquo; app, which is an application that can respond to touch or mouse, and will adapt appropriately to a phone, tablet, or desktop screen. It will even be able to update its display on-the-fly if, say, you plug your phone into a monitor or bluetooth keyboard.</p>

<p>There are <em>lots</em> of ways to write a convergent application with the <a href="https://developer.ubuntu.com/en/phone/platform/sdk/">Ubuntu SDK</a>. You can build apps in pure QML, C++ with QML, QtQuick, pure HTML5/Javascript, or even <strong>Golang with QML</strong>. We&rsquo;ll be focusing on go apps for the rest of this post.</p>

<p>Go is a young language, and the recent release of <a href="https://blog.golang.org/go1.6">go 1.6</a> has introduced some nasty changes particularly involving cgo. It has also introduced vendoring by default, which is a welcome change.</p>

<p>I&rsquo;m using go 1.6.2. For me, the current project template provided by the Ubuntu SDK feels quite broken. I can&rsquo;t get things to build locally, and furthermore I see no options for pushing an ARM build to my device.</p>

<p>Fortunately, I found this <a href="https://github.com/nikwen/ubuntu-go-qml-template">ubuntu-go-qml-template</a> which is a template to enable running/building a go/qml application locally while also supporting building/installing onto an arm device. The kicker? This tool was designed to work for go 1.3.3. Sigh! Since I&rsquo;m unwilling to compromise and use old technology, I <a href="https://github.com/larryprice/ubuntu-go-qml-template">forked the project</a> and updated it to fit my more modern needs.</p>

<p>Because our go template will depend on QML, we depend on the <a href="https://github.com/go-qml/qml">go-qml</a> project to create the necessary C bindings to allow us to use QML. However, with the update to go 1.6, the current version (revision 2ee7e5f) of go-qml will give a runtime error from cgo with the wonderfully helpful <code>panic: runtime error: cgo argument has Go pointer to Go pointer</code>. Another thorn in our side. Fortunately, this issue is in previously tread-upon ground and there is a <a href="https://github.com/sjb/qml/tree/go1.6-port">fork of go-qml</a> with enough of the cgo issues fixed to run our application with no problems. In the <code>ubuntu-go-qml-template</code> I forked above, I&rsquo;ve gone ahead and vendored this fork of <code>go-qml</code>. It all works because of the default vendoring available in go 1.6.</p>

<p>With that background out of the way, let&rsquo;s run through getting a project started:</p>

<pre><code class="bash">$ sudo apt-get install golang g++ qtdeclarative5-dev qtbase5-private-dev \
                       qtdeclarative5-private-dev libqt5opengl5-dev \
                                             qtdeclarative5-qtquick2-plugin
# installing dependencies...
$ git clone https://github.com/larryprice/ubuntu-go-qml-template.git your-project-name
# cloning repo...
$ cd your-project-name
$ chroot-scripts/setup-chroot.sh
# building a chroot for ubuntu-sdk-15.04
# distro=vivid, arch=arm
# with go 1.6.2 with armhf compilation support
</code></pre>

<p>You may need to have other dependencies including <code>click</code> or <code>phablet-tools</code>. The above commands installed dependencies, cloned the repo, and built and/or updated a chroot for building our source for arm.</p>

<p>Next you&rsquo;ll want to setup the project for your own needs. The original template creator included a nifty <code>setup</code> script to get this done:</p>

<pre><code class="bash">$ ruby setup.rb -v -n your-project-name -a "Your Name" -e "your.email@example.com" \
                   -d "your-developer-namespace"
</code></pre>

<p>This will do some fancy gsub and file renaming to make the template your own.</p>

<p>If you check <code>src/</code>, you&rsquo;ll find a <code>main.go</code> file ready for your use. You&rsquo;ll also find a <code>main.qml</code> file in <code>share/qml/</code>. You can vendor all of your dependencies in <code>vendor/</code>, where you&rsquo;ll already find the <code>qml</code> package.</p>

<p>As far as getting your application to work, there are more scripts available:</p>

<pre><code>$ ./build.sh
# this will build your project locally
$ ./run.sh
# this will build your project locally and then run it on the desktop
</code></pre>

<p>The best part about this template is the ability to build for arm and load your applications onto a device:</p>

<pre><code>$ ./build-in-chroot.sh
# builds the package using the vivid+armhf chroot we set up previously
$ ./install-on-device.sh
# builds for vivid+armhf and installs the click directly on
# the first USB-connected Ubuntu Touch device
</code></pre>

<p>Now you can run and install go/qml applications on desktop or on devices. Time to go build something cool!</p>

<p><em>Disclaimer: In the future, this template will likely need to be updated for new go versions or new default versions of the Ubuntu SDK. Don&rsquo;t be afraid to make a comment below or submit a PR.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go for Web Development 50% Off Sale]]></title>
    <link href="https://larry-price.com/blog/2016/01/21/go-for-web-development-50-percent-off-sale/"/>
    <updated>2016-01-21T10:51:22-05:00</updated>
    <id>https://larry-price.com/blog/2016/01/21/go-for-web-development-50-percent-off-sale</id>
    <content type="html"><![CDATA[<p>At the end of 2015, I published a video course on getting started with web development in Go. For the next two weeks, you can get it for 50% off using this link: <a href="http://bit.ly/1PEubnd">http://bit.ly/1PEubnd</a>. With over 2 hours of content for just over $20, it&rsquo;s a great deal. The sale runs from 21 Jan until 4 Feb 2016.</p>

<p><a href="http://bit.ly/1PEubnd"><img src="https://i.imgur.com/tTPQj2b.png" /></a></p>

<p>The video takes the student through every step of creating a personal library web application from scratch, covering concepts such as routing, database access, and authentication. It&rsquo;s a great introduction to go, and an excellent primer to starting your own go-based web project.</p>

<p>All this comes with the added benefit of supporting me: your local developer. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go for Web Development]]></title>
    <link href="https://larry-price.com/blog/2015/12/30/go-for-web-development/"/>
    <updated>2015-12-30T14:54:11-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/30/go-for-web-development</id>
    <content type="html"><![CDATA[<p>I have published a video series on building web applications in Go called <em><a href="https://www.packtpub.com/web-development/go-web-development-video">Go for Web Development</a></em>.</p>

<p>These videos will guide you through the entire process of creating a web application in Go, all the way from spinning up a basic web server to multi-user authentication. In the end, you&rsquo;ll learn how to vendor dependencies and deploy the application to heroku. Throughout the course, you&rsquo;ll learn to utilize many of the most popular go packages including gorilla/mux, negroni, gorp, ace, and bcrypt. You&rsquo;ll learn about making asynchronous requests from the browser back to the web server, and you&rsquo;ll learn to access external REST APIs from your web server. You&rsquo;ll use go&rsquo;s struct tags to parse both XML and JSON, and you&rsquo;ll use struct tags to access database entities with gorp.</p>

<p>I spent many late nights creating this course, and I&rsquo;ve learned a lot of lessons about creating screencasts along the way. I was also able to solidify much of my base understanding of the go language and learn about many features I don&rsquo;t often utilize. The videos are published by Packt Publishing, and they were a great help along the way. The most valuable lesson I learned from doing these screencasts is that a quality microphone makes a huge difference, and I would have saved myself a lot of trouble had I used my Rock Band microphone from the beginning. In the end everything turned out great. I&rsquo;m relieved to be finished and excited to have an official ISBN connected to my name.</p>

<p><s>The video is currently only $5 for the holidays, but</s> the regular retail price is set to $75 (which is still a bargain considering all the content).</p>

<p>Link: <a href="https://www.packtpub.com/web-development/go-web-development-video">https://www.packtpub.com/web-development/go-web-development-video</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML Parsing in Go]]></title>
    <link href="https://larry-price.com/blog/2015/12/04/xml-parsing-in-go/"/>
    <updated>2015-12-04T15:30:14-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/04/xml-parsing-in-go</id>
    <content type="html"><![CDATA[<p>Need to parse an XML file in go? XML (en|de)coding is build into go&rsquo;s standard library. Basic parsing of nodes and embedded nodes is straightforward, but there are some interesting things to think about when you need to parse attributes, lists, and if you don&rsquo;t want to create new structs all over the place.</p>

<p>For this exercise, let&rsquo;s look at the following XML document:</p>

<pre><code class="xml">&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;
</code></pre>

<h3>Defining a Data Structure</h3>

<p>The simplest node to parse is going to be <code>&lt;name&gt;</code>. We&rsquo;ll need an object to unmarshal the XML into, which we&rsquo;ll call <code>Person</code>. Every field on <code>Person</code> will be evaluated by the XML encoder to be populated based on the field&rsquo;s name. However, our struct field names and node names don&rsquo;t usually correspond that simply. Because of this, we&rsquo;ll use <code>xml</code> struct tags to identify how to map each node to a go field. Here&rsquo;s an example for <code>&lt;name&gt;</code>:</p>

<pre><code class="go">type Person struct {
  Name string `xml:"name"`
}
</code></pre>

<p>The next node contains a list of <code>&lt;address&gt;</code> nodes. For an address node, we&rsquo;ll have to create a similar struct with <code>City</code> and <code>Street</code> fields:</p>

<pre><code>type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
}
</code></pre>

<p>While parsing each <code>Address</code>, we also want to find the <code>type</code> of address, which can be found as an attribute on the <code>&lt;address&gt;</code> node. By adding <code>attr</code> to our XML struct tag, we can properly parse the <code>type</code> field as well:</p>

<pre><code class="go">type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
    Type string   `xml:"type,attr"`
}
</code></pre>

<p>A <code>Person</code> has a list of <code>Address</code>es. Since we know that <code>address</code> is a direct descendant, we can use the <code>&gt;</code> keyword to parse each <code>&lt;address&gt;</code> from <code>&lt;addresses&gt;</code> into an embedded struct on our <code>Person</code> struct.</p>

<pre><code class="go">type Person struct {
    Name string         `xml:"name"`
    Addresses []Address `xml:"addresses&gt;address"`
}
</code></pre>

<p>This code will work to parse the original document, but do we really need to define a formal struct for addresses? If there was only one address, we could put all the fields directly on the <code>Person</code> struct. However, since we&rsquo;re dealing with a list, our best option is to use an anonymous struct:</p>

<pre><code class="go">type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}
</code></pre>

<h3>Binding the Data Structure</h3>

<p>We can use the <a href="https://golang.org/pkg/encoding/xml/">encoding/xml</a> package to decode the given XML. Given that our raw XML document is stored in a <code>[]byte</code> called <code>document</code>, we&rsquo;ll use <code>xml.Unmarshal</code> to bind our data structure to the XML document:</p>

<pre><code class="go">var luann Person
xml.Unmarshal(document, &amp;luann)
</code></pre>

<h3>Final Code</h3>

<p>Let&rsquo;s put it all together, including a <code>main</code> function that will use <code>fmt.Println</code> to print the results of binding the data structure to the XML document. <code>Unmarshal</code> could return an error, but we&rsquo;ll ignore it in this case.</p>

<pre><code class="go">package main

import (
    "encoding/xml"
    "fmt"
)

var personXML = []byte(`
&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;`)

type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}

func main() {
    var luann Person
    xml.Unmarshal(personXML, &amp;luann)
    fmt.Println(luann)
}
</code></pre>

<p>I&rsquo;ve posted this code as <a href="https://gist.github.com/larryprice/204fec2e8d33979f8cac">a gist</a> in <a href="https://play.golang.org/p/qiSoxxb5tp">the go playground</a> so you can see it in action.</p>
]]></content>
  </entry>
  
</feed>
