<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: non-technical | Larry Price]]></title>
  <link href="http://larry-price.com/blog/categories/non-technical/atom.xml" rel="self"/>
  <link href="http://larry-price.com/"/>
  <updated>2014-10-29T18:28:59-04:00</updated>
  <id>http://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My Battle With Hour-Based Estimation]]></title>
    <link href="http://larry-price.com/blog/2014/10/29/the-epic-battle-between-estimates-and-getting-work-done/"/>
    <updated>2014-10-29T18:33:27-04:00</updated>
    <id>http://larry-price.com/blog/2014/10/29/the-epic-battle-between-estimates-and-getting-work-done</id>
    <content type="html"><![CDATA[<p>I despise estimating in hours. Hours are too granular. Hours are too difficult to distinguish from hours on a clock (<em>they&rsquo;re even spelled the same</em>).</p>

<p>In any project where we work in hours, we always desparately task out stories in hours fill our capacity. <em>Which is also measured in hours</em>. We take people&rsquo;s days off and we estimate that developers spend about &frac34; of the day watching Youtube videos and reading Hacker News. So a developer works <strong>about 6 clock hours</strong> in a given day.</p>

<p>Then we start tasking out stories. We estimate that this task will take <strong>about 12 hours</strong>, this one <strong>about 8 hours</strong>, and we&rsquo;ll top it all off with a task of <strong>about 4 hours</strong> for ad-hoc testing. All in all, this story is estimated to take <strong>exactly 24 hours</strong>.</p>

<p>Now we do some math. Obviously, since a developer can get <strong>6 hours</strong> of work done in a day and this story will take <strong>24 hours</strong>, the story will be done in <strong>exactly 4 development days</strong>, or <strong>exactly 3 real days</strong>. We watch our capacity (in hours) fill by 24 and note all the space that&rsquo;s left.</p>

<p>Someone without reference to our developer-day-to-work-day comparison walks by. Excellent, it&rsquo;ll be done in three days, you say? That fits the schedule perfectly, tell the client we&rsquo;ll be done with that feature by Thursday. Let&rsquo;s add some more to your backlog&hellip;</p>

<p>For all we know, this estimate may work out. However, from my experience, the 8 hour task and 12 hour task will probably spend about the same amount of time in development, taking anywhere from 1-3 days each. Fortunately, the &ldquo;testing&rdquo; task will only take about 30 minutes.</p>

<p>What&rsquo;s wrong here?</p>

<p>Humans are bad at estimating. We become much worse at estimating when we start talking about knowledge work. I happen to believe we become even worse at estimating when we try to use time as a unit of measure. How long does it take you to get to work? I would say it takes me about 5 minutes. Google Maps tells me I would be lucky to get there in 10 without traffic. My estimation in minutes is <strong>bad</strong>, conflated by the monotony of performing a menial task over and over again.</p>

<p>When we have retros, we don&rsquo;t discuss how incorrect our hourly measurements were. We have a hybrid system of estimating stories in points and tasks in hours. We discuss the discrepancy between estimated and actual story points instead, despite the disconnect between our task estimates and our story estimates. (Another reason we don&rsquo;t discuss hour estimations at the retro is that it would take <strong>forever</strong> due to the high number of tasks and the granularity of hours (did this take one day or two, I can&rsquo;t remember)).</p>

<p>Do I have a solution to this problem? Of course I do. Don&rsquo;t use hours. Stick with points, and keep them as vague and hand-wavey as possible.</p>

<p>We often run into an issue of associating points with number of hours or days. &ldquo;Well, a 3 takes us about a week and a 5 takes us about 2 weeks. This story seems like it&rsquo;ll take about a week.&rdquo;</p>

<p>Points <strong>do not</strong> translate directly to how long a story will take. Points <strong>do</strong> translate to how much work a story feels like relative to the stories which have come before it.</p>

<p>Eventually, you should have a big enough pile of 1s, 2s, 3s, and 5s that you can relate a new story to a previous story. This story feels like a 3, about as much work as that story where we had to herd those cats. This story feels like a 1, technically all I have to do is flip this boolean&hellip;</p>

<p>When starting a project, estimate stories but don&rsquo;t try to estimate a capacity. Just see how many points you can get done in a sprint. Do it again for the second sprint. Keep doing it until your numbers balance out. This means that your estimates are becoming consistent and you&rsquo;re getting over the new project hump. Now you can tell your manager that you should be able to get 20 points done in a sprint, because you&rsquo;ve consistently bounced around that number the past few sprints.</p>

<p>Don&rsquo;t get too hasty and start telling people that you should be able to do more points with each sprint. I hate to break it to you, but you&rsquo;re not getting that much better each sprint. You need to adjust your point estimation to match your current competency level.</p>

<p>End rant. It&rsquo;ll probably be a long time before we see the death of hourly estimations, especially with big-name tools like Rally and Visual Studio Online containing fields explicitly for that purpose. Just fight the good fight for now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To System Test or Not to System Test]]></title>
    <link href="http://larry-price.com/blog/2014/10/28/to-system-test-or-not-to-system-test/"/>
    <updated>2014-10-28T17:42:06-04:00</updated>
    <id>http://larry-price.com/blog/2014/10/28/to-system-test-or-not-to-system-test</id>
    <content type="html"><![CDATA[<p>System tests: a boon to product verification, but also time taken away from raw development. System-level testing means bringing up the whole system and running through a set of steps to verify that the system is working properly on all levels.</p>

<p>We have lots of system tests on our project, some that check for the existence of UI elements, and some that verify that a user can go through the entire e-commerce process. Some of the tests require network access, so they take up to 3 or 4 minutes. I had gotten used to writing system tests with <a href="https://www.ruby-lang.org/en/">ruby</a> and <a href="https://github.com/jnicklas/capybara">capybara</a>, which I&rsquo;ve always found straightforward and easy to write. But this current project is in ASP.NET MVC, which seems to have greatly complicated bringing up and automatically manipulating the system. Our current test suite takes over an hour to run and results in at least 10 consistently-failing tests (referred to as &ldquo;flaky&rdquo; for dignity&rsquo;s sake).</p>

<p>Because of this, there has been talk about getting rid of the system tests.</p>

<p>Getting rid of system tests? Doesn&rsquo;t this go against everything we believe in? Think of TDD! Think of the children! Think of acceptance criteria! Won&rsquo;t somebody think of the children!</p>

<p>So I&rsquo;ve been thinking: what is the purpose of system tests? The first thing that comes to mind is the obvious: to test the full stack. Often components work well individually but throw tantrums when forced to interact with the rest of the system.</p>

<p>Another obvious answer: system health. If the system tests are passing, then surely the site still works after my push! You did add a system test for that changeset, right?</p>

<p>I&rsquo;m not satisfied with those answers. Those are great <em>side effects</em> to writing system tests, but they aren&rsquo;t <em>sustainable</em> reasons. For their own devious reasons, someone can always delete a system test that would have broken with your code change. You can always write your system test steps poorly, resulting in incorrect (though passing) behavior.</p>

<p>The best reason for writing system tests is <strong>to find out what you&rsquo;ve accomplished</strong>.</p>

<p>Sometimes when I finish coding a new feature, I ask myself &ldquo;MY GOD WHAT HAVE I DONE.&rdquo; There are unit tests in place, and they have great names like <code>SetsIsValidToTrue</code> and <code>ReturnsSomethingThatsNotNull</code> and <code>DoesntCrashTheSystem</code>, but they fail to tell me what just happened. So I switch context to the system tests. In writing a system test, I bring up the whole system, run through my Happy Pathâ„¢ and my edge cases, and <strong>I can see precisely what I&rsquo;ve done</strong>. I can watch my work succeed or fail. I can see when it takes way too many complicated page clicks to perform a task. I can see that when I click something too quickly the page fails to load. I can see that the URL is just plain <em>weird</em>. Most importantly, I can sit back and <strong>see</strong> it happening.</p>

<p>So I push my system test to the build server and it works fine until a few dozen other changesets go through on the same page and eventually the system test becomes flaky.</p>

<p>Where did we go wrong?</p>

<p>I have an idea on how to deal with this, but you&rsquo;re probably not going to like it.</p>

<p>As soon as I push a system test, it becomes legacy. You are no longer allowed to edit this system test. If you are updating that feature, you are responsible to <em>delete</em> and potentially <em>rewrite</em> each relevant test. In doing this, you are now required to think about the way the whole system fits together every time you push a feature. System tests will become a picture frozen in time of the way the feature worked the last time it was worked on. System tests will no longer be <em>a rolling history of what the system did</em>, but <em>an exact specification of what the system does</em>. They become a piece of the development process to demonstrate the intended functionality of the feature.</p>

<p>In following this practice, we technically lose out on reusable system test code. I say good riddance, as testing code is the quickest part of any system to become bloated and convoluted. The loss in test creation speed could be worth the gain in developer knowledge of the intricacies of the system.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The (Honest) Truth About Dishonesty]]></title>
    <link href="http://larry-price.com/blog/2014/08/31/the-honest-truth-about-dishonesty/"/>
    <updated>2014-08-31T13:35:40-04:00</updated>
    <id>http://larry-price.com/blog/2014/08/31/the-honest-truth-about-dishonesty</id>
    <content type="html"><![CDATA[<h3>The Idea</h3>

<p>Everyone lies. Everyone cheats. From Marcy down the street cheating on her diet to Bernie Madoff committing massive finanical fraud, we&rsquo;re all a little dishonest from time to time. With the power of experimentats and research, Dan Ariely seeks to learn what leads humans to act dishonestly in <em><a href="http://amzn.to/1qsOgTy">The (Honest) Truth About Dishonesty</a></em>.</p>

<h3>The Gooey Center</h3>

<p>Since reading <em><a href="http://amzn.to/VYzVTZ">Predictably Irrational</a></em> earlier this year, I&rsquo;ve really liked reading Dan Ariely; his writing style is familiar yet authoritative, making for highly readable books filled with high-quality experiments and meaningful insights. <em>The (Honest) Truth About Dishonesty</em> is a similar read to <em>Predictably Irrational</em>, but with a tight focus on what drives the common man to lie and cheat.</p>

<p>The main takeaway is, given the chance, most people will cheat just a little given the opportunity. Ariely&rsquo;s experiments found that very few people cheated heavily, even in situations where the likelihood of being caught is minimal. Rounding up your billable hours on a timesheet is easy to do without a shred of guilt, and the likelihood of getting caught is approximately nil. On the other hand, fudging an hour or two in a single day is not something anyone I know would take lightly. Unfortunately, if you round up billable hours by 10 minutes a day for a whole week, you&rsquo;ve fudged nearly an hour of billable work (without the guilt).</p>

<p>Day-to-day living makes us less honest. If you&rsquo;ve had a long day at work, you&rsquo;re more likely to cheat on your diet when you get home because your defenses have been torn down. You&rsquo;re more likely to put things off in favor of sitting around watching television.</p>

<p>Ariely finds that collaboration also leads to more dishonesty: as humans, we are more willing to bend the rules if it will benefit someone else, especially if we have befriended that someone else.</p>

<h3>Who Would Like This</h3>

<p>Those interested in behavioral economics should get a kick out of this book, especially if they enjoyed Ariely&rsquo;s other works. Reading this book can also make you think more critically about some of the &ldquo;little white lies&rdquo; you tell yourself and others throught the day.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ollert - Reveal The Data Behind Your Trello Boards]]></title>
    <link href="http://larry-price.com/blog/2014/07/13/ollert-reveal-the-data-behind-your-trello-boards/"/>
    <updated>2014-07-13T17:15:00-04:00</updated>
    <id>http://larry-price.com/blog/2014/07/13/ollert-reveal-the-data-behind-your-trello-boards</id>
    <content type="html"><![CDATA[<p>Introducing <a href="https://ollertapp.com">Ollert</a>, a tool to show you what your <a href="//trello.com">Trello</a> boards can&rsquo;t tell you on their own.</p>

<p>Trello does a great job of telling you about the here and now of your Trello boards; who&rsquo;s working on what task and what is the current state of a task. But what if I want to know about the state of the whole project? How many work items have we finished in the past sprint, iteration, or duration of the project? He who does not understand the past is destined to repeat his mistakes ad nauseum.</p>

<p>Ollert is a tool with these ideas in mind. Authorize Ollert access to your Trello account, select the board you would like to learn more about, and see all the battle scars your board has experienced throughout the duration of the project.</p>

<p>Learn about your velocity through a Cumulative Flow Diagram. View your work in progress with a WIP chart. See which labels your team uses most frequently with our label chart. See information about your cards and lists from a historical perspective.</p>

<p><a href="https://ollertapp.com/signup">Create an account</a> with Ollert to show your support. Users who sign up for an Ollert account will have their Trello authorization saved, saving the hassle of authorizing with Trello every time the user visits the site. An Ollert account is perfect for any user who views board progress frequently, or for creating a continuous display on an office monitor.</p>

<p>Since Ollert&rsquo;s initial release <a href="/blog/2014/03/17/sep-startup-weekend-ollert/">several months ago</a>, Ollert now boasts over 4000% faster load times, increased data security using SSL and encrypted cookies, and a more consistent Trello connection experience in all modern web browsers.</p>

<p>Discover Ollert now at <a href="https://ollertapp.com">ollertapp.com</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lessons Learned during the Conception of Ollert]]></title>
    <link href="http://larry-price.com/blog/2014/06/12/lessons-learned-during-the-conception-of-ollert/"/>
    <updated>2014-06-12T20:32:00-04:00</updated>
    <id>http://larry-price.com/blog/2014/06/12/lessons-learned-during-the-conception-of-ollert</id>
    <content type="html"><![CDATA[<p>During <a href="http://sep.com">SEP&rsquo;s</a> previous <a href="http://sep.com/labs/">startup weekend</a>, I pitched an idea for a <a href="http://trello.com">Trello</a> Analysis Tool called <a href="https://ollertapp.com">Ollert</a>. In less than three days, a team of 6 built a minimal viable product (MVP) and put it live on the internet. In a little over three months, I have slowly guided Ollert through the legal department, obtained a real domain with security, and fixed a few bugs along the way. I&rsquo;ve learned a thing or two about seeing a hackathon project to fruition that I&rsquo;d like to get in writing.</p>

<h3>1. You Can Never Be Too Prepared</h3>

<p>Before Startup Weekend, I spent days refining my idea and coming up with a cute little proof of concept. I even laid out work items for my developers to work on. When I finally discovered a clever name, I thought my preparation was over.</p>

<p>I was wrong.</p>

<p>Although I requested 5 developers to help me build Ollert, my plans only allowed for two developers to work simultaneously. I didn&rsquo;t realize how hard it would be to keep everyone busy all the time, especially my less-experienced engineers.</p>

<p>Although I did proof-of-concept my idea before we started, I failed to proof-of-concept the more dynamic capabilities a multi-user web application needs to provide. This mistake cost another developer and I the first night of the weekend, plus a bit of the next morning.</p>

<p>Don&rsquo;t even get me started about environment setup. Although I run <a href="http://www.ubuntu.com">Ubuntu</a> natively and had all my developer tools ready before we started work Friday night, the rest of my team were users of That Other Operating System. I should have created a virtual machine with everything all set up, burned it to several USB drives, and let my developers set up VirtualBox without my intervention.</p>

<h3>2. Talk to Legal</h3>

<p>Why do I care about legal? Isn&rsquo;t this my responsibility anyway?</p>

<p>As it turns out, putting a startup weekend project live on the internet before the weekend is over is really cool from a team perspective, but terrifying from a legal perspective. With our MVP, I wasn&rsquo;t using SSL to encrypt user data. I didn&rsquo;t consider how Fog Creek would react once they realized our name is their name backwards. I even had the chutzpah to stick my company&rsquo;s logo in my site&rsquo;s footer.</p>

<p>A quick discussion with management will prepare both sides for the &ldquo;grand reveal&rdquo; if the project makes it to launch. Personally, I&rsquo;d like to see some level of legal counsel in the Startup Weekend &ldquo;pre-pitch&rdquo; session to get feedback before implementation.</p>

<h3>3. Listen</h3>

<p>The second day, one of my developers mentioned using endpoints in the application, and I rejected this idea on the basis that it was too complicated. On the dawn of the final day, we realized that we needed to use his approach or the application would be unusable. This required us to do a lot of rework that could have been avoided. I often think about what other ideas might have been suggested by my team that I may have accidentally ignored.</p>

<h3>4. Easy Tasks</h3>

<p>My assumption going into Startup Weekend was that my team would all be familiar enough with the technology to be able to &ldquo;jump right in&rdquo; or follow along with someone who could. This was a bad assumption.</p>

<p>It&rsquo;s easy to find tasks that <em>I</em> can do. It&rsquo;s much more difficult to find tasks that <em>anyone</em> could do. What are the less-involved tasks on your current project that a less-experienced developer could work on until they&rsquo;re ready to tackle something bigger? Can they set up the database, or the tests? Can you find a guide for them to follow to do these things? If not, you&rsquo;ll have people on your team who don&rsquo;t feel involved but desperately want to help.</p>

<h3>5. Start Small</h3>

<p>Ollert is a pretty big idea, especially for a three-day project. I had high hopes of making it even bigger until the dawn of the final day. I wanted to include some sort of payment system to prove that we would be able to charge people when they sign up without actually charging them. This &ldquo;feature&rdquo; of fake payment has no place in a real product, and would have been misleading at best. We had dozens of ideas for statistics and charts to make it into the website that just weren&rsquo;t that useful.</p>

<p>Limiting scope might have allowed us to come up with a more polished MVP; I walked away the final evening wishing I had left out sign up/in in favor of giving the application more sex appeal.</p>

<h3>Conclusion</h3>

<p>Starting a project is hard. It&rsquo;s even more difficult when you have to delegate most of the work to other people. Startup Weekend is a manger and a mortuary, seeing the birth of many ideas and the death of most. I hope to take this experience and make an even better new product next Startup Weekend.</p>
]]></content>
  </entry>
  
</feed>
