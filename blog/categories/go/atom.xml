<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Larry Price]]></title>
  <link href="https://larry-price.com/blog/categories/go/atom.xml" rel="self"/>
  <link href="https://larry-price.com/"/>
  <updated>2020-11-03T11:30:15-06:00</updated>
  <id>https://larry-price.com/</id>
  <author>
    <name><![CDATA[Larry Price]]></name>
    <email><![CDATA[larry@larry-price.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick Start to Vendor Go Dependencies with govendor]]></title>
    <link href="https://larry-price.com/blog/2018/04/26/quick-start-to-vendor-go-dependencies-with-govendor/"/>
    <updated>2018-04-26T19:34:04-05:00</updated>
    <id>https://larry-price.com/blog/2018/04/26/quick-start-to-vendor-go-dependencies-with-govendor</id>
    <content type="html"><![CDATA[<p>I recently spent a few days adapting my <a href="https://www.packtpub.com/web-development/go-web-development-video">Go for Web Development video series</a> into a text-based course. In doing so, I had the chance to investigate some of the new vendoring tools available in Go. As of Go 1.5, &ldquo;vendoring&rdquo; dependencies has become the norm. Vendoring means tracking your dependencies and their versions and including those dependencies as part of your project.</p>

<p>In particular, I explored the uses of the <a href="https://github.com/kardianos/govendor">govendor</a> package, mostly because it&rsquo;s supported by default by Heroku. The docs on the GitHub are a lot more thorough than what I&rsquo;ll go over here.</p>

<p><code>govendor</code> is easily installed within the go ecosystem. Assuming that <code>$GOPATH/bin</code> is in your path:</p>

<pre><code class="bash">$ go get -u github.com/kardianos/govendor
$ which govendor
/home/lrp/go/bin/govendor
</code></pre>

<p>Now we just initialize the <code>govendor</code> directory and start installing dependencies. The <code>govendor fetch</code> command is pretty much all you&rsquo;ll need:</p>

<pre><code class="bash">$ govendor init
$ govendor fetch github.com/jinzhu/gorm
$ govendor fetch golang.org/x/crypto/bcrypt
</code></pre>

<p><code>init</code> will create a <code>vendor</code> directory in your project path. Go will check this directory for any packages as though they were in your <code>$GOPATH/src</code> directory. The <code>fetch</code> calls will add new packages or update the given package in your <code>vendor</code> directory; in this case, I&rsquo;ve fetched the latest versions of <code>gorm</code> and <code>bcrypt</code>.</p>

<p>This might seem painful, but the thing to do next is to commit everything in the vendor directory to your repository. Now you have it forever! This means that anyone who wants to run this version of your code in the future doesn&rsquo;t have to worry about dependency versions and can instantly run your package with a valid go install.</p>

<p>If you don&rsquo;t want to add all these packages to your repository, I don&rsquo;t blame you. You can get around this by committing just your <code>vendor/vendor.json</code> file and then using <code>govendor sync</code> to install the missing packages after downloading your source code. This should be familiar to anyone who&rsquo;s used <code>bundler</code> in ruby, <code>virtualenv</code> in python, or <code>npm</code> in Node.JS. If you&rsquo;re using git, you&rsquo;ll want a <code>.gitignore</code> with the following:</p>

<pre><code>vendor/*
!vendor/vendor.json
</code></pre>

<p>This will ignore everything in <code>vendor/</code> except for the <code>vendor.json</code> file which lists all your packages and their corresponding versions. Now, to install any packages from <code>vendor.json</code> that you don&rsquo;t already have in your <code>vendor</code> directory:</p>

<pre><code class="bash">$ govendor sync
</code></pre>

<p><code>govendor</code> is a pretty powerful tool for vendoring your go dependencies and getting your application Heroku-ready, and I recommend <a href="https://github.com/kardianos/govendor">checking out the docs</a> for a more advanced overview. There are also many other vendoring options available, including an official go vendoring tool called <a href="https://github.com/golang/dep">dep</a> that works with go 1.9+. <code>dep</code> will most definitely play a big role in refining the ideas that these third-party tools have created and the go ecosystem will become more stable.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML Parsing in Go]]></title>
    <link href="https://larry-price.com/blog/2015/12/04/xml-parsing-in-go/"/>
    <updated>2015-12-04T15:30:14-05:00</updated>
    <id>https://larry-price.com/blog/2015/12/04/xml-parsing-in-go</id>
    <content type="html"><![CDATA[<p>Need to parse an XML file in go? XML (en|de)coding is build into go&rsquo;s standard library. Basic parsing of nodes and embedded nodes is straightforward, but there are some interesting things to think about when you need to parse attributes, lists, and if you don&rsquo;t want to create new structs all over the place.</p>

<p>For this exercise, let&rsquo;s look at the following XML document:</p>

<pre><code class="xml">&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;
</code></pre>

<h3>Defining a Data Structure</h3>

<p>The simplest node to parse is going to be <code>&lt;name&gt;</code>. We&rsquo;ll need an object to unmarshal the XML into, which we&rsquo;ll call <code>Person</code>. Every field on <code>Person</code> will be evaluated by the XML encoder to be populated based on the field&rsquo;s name. However, our struct field names and node names don&rsquo;t usually correspond that simply. Because of this, we&rsquo;ll use <code>xml</code> struct tags to identify how to map each node to a go field. Here&rsquo;s an example for <code>&lt;name&gt;</code>:</p>

<pre><code class="go">type Person struct {
  Name string `xml:"name"`
}
</code></pre>

<p>The next node contains a list of <code>&lt;address&gt;</code> nodes. For an address node, we&rsquo;ll have to create a similar struct with <code>City</code> and <code>Street</code> fields:</p>

<pre><code>type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
}
</code></pre>

<p>While parsing each <code>Address</code>, we also want to find the <code>type</code> of address, which can be found as an attribute on the <code>&lt;address&gt;</code> node. By adding <code>attr</code> to our XML struct tag, we can properly parse the <code>type</code> field as well:</p>

<pre><code class="go">type Address struct {
    Street string `xml:"street"`
    City string   `xml:"city"`
    Type string   `xml:"type,attr"`
}
</code></pre>

<p>A <code>Person</code> has a list of <code>Address</code>es. Since we know that <code>address</code> is a direct descendant, we can use the <code>&gt;</code> keyword to parse each <code>&lt;address&gt;</code> from <code>&lt;addresses&gt;</code> into an embedded struct on our <code>Person</code> struct.</p>

<pre><code class="go">type Person struct {
    Name string         `xml:"name"`
    Addresses []Address `xml:"addresses&gt;address"`
}
</code></pre>

<p>This code will work to parse the original document, but do we really need to define a formal struct for addresses? If there was only one address, we could put all the fields directly on the <code>Person</code> struct. However, since we&rsquo;re dealing with a list, our best option is to use an anonymous struct:</p>

<pre><code class="go">type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}
</code></pre>

<h3>Binding the Data Structure</h3>

<p>We can use the <a href="https://golang.org/pkg/encoding/xml/">encoding/xml</a> package to decode the given XML. Given that our raw XML document is stored in a <code>[]byte</code> called <code>document</code>, we&rsquo;ll use <code>xml.Unmarshal</code> to bind our data structure to the XML document:</p>

<pre><code class="go">var luann Person
xml.Unmarshal(document, &amp;luann)
</code></pre>

<h3>Final Code</h3>

<p>Let&rsquo;s put it all together, including a <code>main</code> function that will use <code>fmt.Println</code> to print the results of binding the data structure to the XML document. <code>Unmarshal</code> could return an error, but we&rsquo;ll ignore it in this case.</p>

<pre><code class="go">package main

import (
    "encoding/xml"
    "fmt"
)

var personXML = []byte(`
&lt;person&gt;
    &lt;name&gt;Luann Van Houten&lt;/name&gt;
    &lt;addresses&gt;
        &lt;address type="secondary"&gt;
            &lt;street&gt;321 MadeUp Lane&lt;/street&gt;
            &lt;city&gt;Shelbyville&lt;/city&gt;
        &lt;/address&gt;
        &lt;address type="primary"&gt;
            &lt;street&gt;123 Fake St&lt;/street&gt;
            &lt;city&gt;Springfield&lt;/city&gt;
        &lt;/address&gt;
    &lt;/addresses&gt;
&lt;/person&gt;`)

type Person struct {
    Name      string `xml:"name"`
    Addresses []struct {
        Street string `xml:"street"`
        City   string `xml:"city"`
        Type   string `xml:"type,attr"`
    } `xml:"addresses&gt;address"`
}

func main() {
    var luann Person
    xml.Unmarshal(personXML, &amp;luann)
    fmt.Println(luann)
}
</code></pre>

<p>I&rsquo;ve posted this code as <a href="https://gist.github.com/larryprice/204fec2e8d33979f8cac">a gist</a> in <a href="https://play.golang.org/p/qiSoxxb5tp">the go playground</a> so you can see it in action.</p>
]]></content>
  </entry>
  
</feed>
